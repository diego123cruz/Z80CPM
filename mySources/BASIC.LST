0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             
0022   0000             ; GENERAL EQUATES
0023   0000             
0024   0000             CTRLC   .EQU    03H             ; Control "C"
0025   0000             CTRLG   .EQU    07H             ; Control "G"
0026   0000             BKSP    .EQU    08H             ; Back space
0027   0000             LF      .EQU    0AH             ; Line feed
0028   0000             CS      .EQU    0CH             ; Clear screen
0029   0000             CR      .EQU    0DH             ; Carriage return
0030   0000             CTRLO   .EQU    0FH             ; Control "O"
0031   0000             CTRLQ	.EQU	11H		        ; Control "Q"
0032   0000             CTRLR   .EQU    12H             ; Control "R"
0033   0000             CTRLS   .EQU    13H             ; Control "S"
0034   0000             CTRLU   .EQU    15H             ; Control "U"
0035   0000             ESC     .EQU    1BH             ; Escape
0036   0000             DEL     .EQU    7FH             ; Delete
0037   0000             
0038   0000             ; BASIC WORK SPACE LOCATIONS
0039   0000             
0040   0000             WRKSPC  .EQU    4090H             ; BASIC Work space
0041   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0042   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0043   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0044   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0045   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0046   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0047   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0048   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0049   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0050   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0051   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0052   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0053   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0054   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0055   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0056   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0057   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0058   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0059   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0060   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0061   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0062   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0063   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0064   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0065   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0066   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0067   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0068   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0069   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0070   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0071   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0072   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0073   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0074   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0075   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0076   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0077   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0078   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0079   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0080   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0081   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0082   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0083   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0084   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0085   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0086   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0087   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0088   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0089   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0090   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0091   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0092   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0093   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0094   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0095   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0096   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0097   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0098   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0103   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0104   0000             
0105   0000             ; BASIC ERROR CODE VALUES
0106   0000             
0107   0000             NF      .EQU    00H             ; NEXT without FOR
0108   0000             SN      .EQU    02H             ; Syntax error
0109   0000             RG      .EQU    04H             ; RETURN without GOSUB
0110   0000             OD      .EQU    06H             ; Out of DATA
0111   0000             FC      .EQU    08H             ; Function call error
0112   0000             OV      .EQU    0AH             ; Overflow
0113   0000             OM      .EQU    0CH             ; Out of memory
0114   0000             UL      .EQU    0EH             ; Undefined line number
0115   0000             BS      .EQU    10H             ; Bad subscript
0116   0000             DD      .EQU    12H             ; Re-DIMensioned array
0117   0000             DZ      .EQU    14H             ; Division by zero (/0)
0118   0000             ID      .EQU    16H             ; Illegal direct
0119   0000             TM      .EQU    18H             ; Type miss-match
0120   0000             OS      .EQU    1AH             ; Out of string space
0121   0000             LS      .EQU    1CH             ; String too long
0122   0000             ST      .EQU    1EH             ; String formula too complex
0123   0000             CN      .EQU    20H             ; Can't CONTinue
0124   0000             UF      .EQU    22H             ; UnDEFined FN function
0125   0000             MO      .EQU    24H             ; Missing operand
0126   0000             HX      .EQU    26H             ; HEX error
0127   0000             BN      .EQU    28H             ; BIN error
0128   0000             
0129   2000                     .ORG    02000H
0130   2000             
0131   2000 C3 06 20    COLD:   JP      STARTB          ; Jump for cold start
0132   2003 C3 A4 20    WARM:   JP      WARMST          ; Jump for warm start
0133   2006             STARTB: 
0134   2006 DD 21 00 00         LD      IX,0            ; Flag cold start
0135   200A C3 11 20            JP      CSTART          ; Jump to initialise
0136   200D             
0137   200D B7 28               .WORD   DEINT           ; Get integer -32768 to 32767
0138   200F 2D 30               .WORD   ABPASS          ; Return integer in AB
0139   2011             
0140   2011             
0141   2011 21 90 40    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0142   2014 F9                  LD      SP,HL           ; Set up a temporary stack
0143   2015 C3 4C 3C            JP      INITST          ; Go to initialise
0144   2018             
0145   2018 11 DE 22    INIT:   LD      DE,INITAB       ; Initialise workspace
0146   201B 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0147   201D 21 90 40            LD      HL,WRKSPC       ; Into workspace RAM
0148   2020 1A          COPY:   LD      A,(DE)          ; Get source
0149   2021 77                  LD      (HL),A          ; To destination
0150   2022 23                  INC     HL              ; Next destination
0151   2023 13                  INC     DE              ; Next source
0152   2024 05                  DEC     B               ; Count bytes
0153   2025 C2 20 20            JP      NZ,COPY         ; More to move
0154   2028 F9                  LD      SP,HL           ; Temporary stack
0155   2029 CD DF 24            CALL    CLREG           ; Clear registers and stack
0156   202C CD AD 2A            CALL    PRNTCRLF        ; Output CRLF
0157   202F 32 3A 41            LD      (BUFFER+72+1),A ; Mark end of buffer
0158   2032 32 89 41            LD      (PROGST),A      ; Initialise program area
0159   2035 21 F3 20    MSIZE:  LD      HL,MEMMSG       ; Point to message
0160   2038 CD 4B 31            CALL    PRS             ; Output "Memory size"
0161   203B CD FC 24            CALL    PROMPT          ; Get input with '?'
0162   203E CD 05 28            CALL    GETCHR          ; Get next character
0163   2041 B7                  OR      A               ; Set flags
0164   2042 C2 5A 20            JP      NZ,TSTMEM       ; If number - Test if RAM there
0165   2045 21 ED 41            LD      HL,STLOOK       ; Point to start of RAM
0166   2048 23          MLOOP:  INC     HL              ; Next byte
0167   2049 7C                  LD      A,H             ; Above address FFFF ?
0168   204A B5                  OR      L
0169   204B CA 6C 20            JP      Z,SETTOP        ; Yes - 64K RAM
0170   204E 7E                  LD      A,(HL)          ; Get contents
0171   204F 47                  LD      B,A             ; Save it
0172   2050 2F                  CPL                     ; Flip all bits
0173   2051 77                  LD      (HL),A          ; Put it back
0174   2052 BE                  CP      (HL)            ; RAM there if same
0175   2053 70                  LD      (HL),B          ; Restore old contents
0176   2054 CA 48 20            JP      Z,MLOOP         ; If RAM - test next byte
0177   2057 C3 6C 20            JP      SETTOP          ; Top of RAM found
0178   205A             
0179   205A CD D1 28    TSTMEM: CALL    ATOH            ; Get high memory into DE
0180   205D B7                  OR      A               ; Set flags on last byte
0181   205E C2 AD 23            JP      NZ,SNERR        ; ?SN Error if bad character
0182   2061 EB                  EX      DE,HL           ; Address into HL
0183   2062 2B                  DEC     HL              ; Back one byte
0184   2063 3E D9               LD      A,11011001B     ; Test byte
0185   2065 46                  LD      B,(HL)          ; Get old contents
0186   2066 77                  LD      (HL),A          ; Load test byte
0187   2067 BE                  CP      (HL)            ; RAM there if same
0188   2068 70                  LD      (HL),B          ; Restore old contents
0189   2069 C2 35 20            JP      NZ,MSIZE        ; Ask again if no RAM
0190   206C             
0191   206C 2B          SETTOP: DEC     HL              ; Back one byte
0192   206D 11 EC 41            LD      DE,STLOOK-1     ; See if enough RAM
0193   2070 CD 75 26            CALL    CPDEHL          ; Compare DE with HL
0194   2073 DA 35 20            JP      C,MSIZE         ; Ask again if not enough RAM
0195   2076 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0196   2079 22 3F 41            LD      (LSTRAM),HL     ; Save last available RAM
0197   207C 19                  ADD     HL,DE           ; Allocate string space
0198   207D 22 EA 40            LD      (STRSPC),HL     ; Save string space
0199   2080 CD BA 24            CALL    CLRPTR          ; Clear program area
0200   2083 2A EA 40            LD      HL,(STRSPC)     ; Get end of memory
0201   2086 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0202   2089 19                  ADD     HL,DE           ; Adjust HL
0203   208A 11 89 41            LD      DE,PROGST       ; Start of program text
0204   208D 7D                  LD      A,L             ; Get LSB
0205   208E 93                  SUB     E               ; Adjust it
0206   208F 6F                  LD      L,A             ; Re-save
0207   2090 7C                  LD      A,H             ; Get MSB
0208   2091 9A                  SBC     A,D             ; Adjust it
0209   2092 67                  LD      H,A             ; Re-save
0210   2093 E5                  PUSH    HL              ; Save bytes free
0211   2094 21 BC 20            LD      HL,SIGNON       ; Sign-on message
0212   2097 CD 4B 31            CALL    PRS             ; Output string
0213   209A E1                  POP     HL              ; Get bytes free back
0214   209B CD EE 37            CALL    PRNTHL          ; Output amount of free memory
0215   209E 21 AD 20            LD      HL,BFREE        ; " Bytes free" message
0216   20A1 CD 4B 31            CALL    PRS             ; Output string
0217   20A4             
0218   20A4 31 F6 40    WARMST: LD      SP,STACK        ; Temporary stack
0219   20A7 CD DF 24    BRKRET: CALL    CLREG           ; Clear registers and stack
0220   20AA C3 F8 23            JP      PRNTOK          ; Go to get command line
0221   20AD             
0222   20AD 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0222   20B3 20667265650D0A0000
0223   20BC             
0224   20BC 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0224   20C2 5349432056657220342E37620D0A
0225   20D0 436F70797269        .BYTE   "Copyright ",40,"C",41
0225   20D6 67687420284329
0226   20DD 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0226   20E3 6279204D6963726F736F66740D0A0000
0227   20F3             
0228   20F3 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0228   20F9 20746F7000
0229   20FE             
0230   20FE             ; FUNCTION ADDRESS TABLE
0231   20FE             
0232   20FE 63 36       FNCTAB: .WORD   SGN
0233   2100 27 37               .WORD   INT
0234   2102 79 36               .WORD   ABS
0235   2104 93 40               .WORD   USR
0236   2106 0B 30               .WORD   FRE
0237   2108 90 33               .WORD   INP
0238   210A 39 30               .WORD   POS
0239   210C ED 38               .WORD   SQR
0240   210E CC 39               .WORD   RND
0241   2110 08 35               .WORD   LOG
0242   2112 3B 39               .WORD   EXP
0243   2114 41 3A               .WORD   COS
0244   2116 47 3A               .WORD   SIN
0245   2118 A8 3A               .WORD   TAN
0246   211A BD 3A               .WORD   ATN
0247   211C E4 33               .WORD   PEEK
0248   211E 28 3B               .WORD   DEEK
0249   2120 E1 40               .WORD   POINT
0250   2122 BD 32               .WORD   LEN
0251   2124 D5 30               .WORD   STR
0252   2126 57 33               .WORD   VAL
0253   2128 CC 32               .WORD   ASC
0254   212A DD 32               .WORD   CHR
0255   212C 4A 3B               .WORD   HEX
0256   212E DD 3B               .WORD   BIN
0257   2130 ED 32               .WORD   LEFT
0258   2132 1D 33               .WORD   RIGHT
0259   2134 27 33               .WORD   MID
0260   2136             
0261   2136             ; RESERVED WORD LIST
0262   2136             
0263   2136 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0264   2139 C6 4F 52            .BYTE   'F'+80H,"OR"
0265   213C CE 45 58 54         .BYTE   'N'+80H,"EXT"
0266   2140 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0267   2144 C94E505554          .BYTE   'I'+80H,"NPUT"
0268   2149 C4 49 4D            .BYTE   'D'+80H,"IM"
0269   214C D2 45 41 44         .BYTE   'R'+80H,"EAD"
0270   2150 CC 45 54            .BYTE   'L'+80H,"ET"
0271   2153 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0272   2157 D2 55 4E            .BYTE   'R'+80H,"UN"
0273   215A C9 46               .BYTE   'I'+80H,"F"
0274   215C D24553544F52        .BYTE   'R'+80H,"ESTORE"
0274   2162 45
0275   2163 C74F535542          .BYTE   'G'+80H,"OSUB"
0276   2168 D2455455524E        .BYTE   'R'+80H,"ETURN"
0277   216E D2 45 4D            .BYTE   'R'+80H,"EM"
0278   2171 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0279   2175 CF 55 54            .BYTE   'O'+80H,"UT"
0280   2178 CF 4E               .BYTE   'O'+80H,"N"
0281   217A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0282   217E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0283   2182 C4 45 46            .BYTE   'D'+80H,"EF"
0284   2185 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0285   2189 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0286   218D D3435245454E        .BYTE   'S'+80H,"CREEN"
0287   2193 CC494E4553          .BYTE   'L'+80H,"INES"
0288   2198 C3 4C 53            .BYTE   'C'+80H,"LS"
0289   219B D749445448          .BYTE   'W'+80H,"IDTH"
0290   21A0 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0290   21A6 52
0291   21A7 D3 45 54            .BYTE   'S'+80H,"ET"
0292   21AA D245534554          .BYTE   'R'+80H,"ESET"
0293   21AF D052494E54          .BYTE   'P'+80H,"RINT"
0294   21B4 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0295   21B8 CC 49 53 54         .BYTE   'L'+80H,"IST"
0296   21BC C34C454152          .BYTE   'C'+80H,"LEAR"
0297   21C1 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0298   21C6 C353415645          .BYTE   'C'+80H,"SAVE"
0299   21CB CE 45 57            .BYTE   'N'+80H,"EW"
0300   21CE             
0301   21CE D4 41 42 28         .BYTE   'T'+80H,"AB("
0302   21D2 D4 4F               .BYTE   'T'+80H,"O"
0303   21D4 C6 4E               .BYTE   'F'+80H,"N"
0304   21D6 D3 50 43 28         .BYTE   'S'+80H,"PC("
0305   21DA D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0306   21DE CE 4F 54            .BYTE   'N'+80H,"OT"
0307   21E1 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0308   21E5             
0309   21E5 AB                  .BYTE   '+'+80H
0310   21E6 AD                  .BYTE   '-'+80H
0311   21E7 AA                  .BYTE   '*'+80H
0312   21E8 AF                  .BYTE   '/'+80H
0313   21E9 DE                  .BYTE   '^'+80H
0314   21EA C1 4E 44            .BYTE   'A'+80H,"ND"
0315   21ED CF 52               .BYTE   'O'+80H,"R"
0316   21EF BE                  .BYTE   '>'+80H
0317   21F0 BD                  .BYTE   '='+80H
0318   21F1 BC                  .BYTE   '<'+80H
0319   21F2             
0320   21F2 D3 47 4E            .BYTE   'S'+80H,"GN"
0321   21F5 C9 4E 54            .BYTE   'I'+80H,"NT"
0322   21F8 C1 42 53            .BYTE   'A'+80H,"BS"
0323   21FB D5 53 52            .BYTE   'U'+80H,"SR"
0324   21FE C6 52 45            .BYTE   'F'+80H,"RE"
0325   2201 C9 4E 50            .BYTE   'I'+80H,"NP"
0326   2204 D0 4F 53            .BYTE   'P'+80H,"OS"
0327   2207 D3 51 52            .BYTE   'S'+80H,"QR"
0328   220A D2 4E 44            .BYTE   'R'+80H,"ND"
0329   220D CC 4F 47            .BYTE   'L'+80H,"OG"
0330   2210 C5 58 50            .BYTE   'E'+80H,"XP"
0331   2213 C3 4F 53            .BYTE   'C'+80H,"OS"
0332   2216 D3 49 4E            .BYTE   'S'+80H,"IN"
0333   2219 D4 41 4E            .BYTE   'T'+80H,"AN"
0334   221C C1 54 4E            .BYTE   'A'+80H,"TN"
0335   221F D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0336   2223 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0337   2227 D04F494E54          .BYTE   'P'+80H,"OINT"
0338   222C CC 45 4E            .BYTE   'L'+80H,"EN"
0339   222F D3 54 52 24         .BYTE   'S'+80H,"TR$"
0340   2233 D6 41 4C            .BYTE   'V'+80H,"AL"
0341   2236 C1 53 43            .BYTE   'A'+80H,"SC"
0342   2239 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0343   223D C8 45 58 24         .BYTE   'H'+80H,"EX$"
0344   2241 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0345   2245 CC45465424          .BYTE   'L'+80H,"EFT$"
0346   224A D24947485424        .BYTE   'R'+80H,"IGHT$"
0347   2250 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0348   2254 80                  .BYTE   80H             ; End of list marker
0349   2255             
0350   2255             ; KEYWORD ADDRESS TABLE
0351   2255             
0352   2255 4F 28       WORDTB: .WORD   PEND
0353   2257 4C 27               .WORD   FOR
0354   2259 27 2C               .WORD   NEXT
0355   225B 9C 29               .WORD   DATA
0356   225D 2E 2B               .WORD   INPUT
0357   225F 63 2E               .WORD   DIM
0358   2261 5D 2B               .WORD   READ
0359   2263 B3 29               .WORD   LET
0360   2265 59 29               .WORD   GOTO
0361   2267 3C 29               .WORD   RUN
0362   2269 2B 2A               .WORD   IF
0363   226B 15 28               .WORD   RESTOR
0364   226D 48 29               .WORD   GOSUB
0365   226F 77 29               .WORD   RETURN
0366   2271 9E 29               .WORD   REM
0367   2273 4D 28               .WORD   STOP
0368   2275 9C 33               .WORD   POUT
0369   2277 0D 2A               .WORD   ON
0370   2279 8E 28               .WORD   NULL
0371   227B A2 33               .WORD   WAIT
0372   227D 41 30               .WORD   DEF
0373   227F EB 33               .WORD   POKE
0374   2281 33 3B               .WORD   DOKE
0375   2283 9E 29               .WORD   REM
0376   2285 19 3B               .WORD   LINES
0377   2287 0C 3B               .WORD   CLS
0378   2289 11 3B               .WORD   WIDTH
0379   228B 49 3C               .WORD   MONITR
0380   228D E4 40               .WORD   PSET
0381   228F E7 40               .WORD   RESET
0382   2291 4F 2A               .WORD   PRINT
0383   2293 7B 28               .WORD   CONT
0384   2295 C1 26               .WORD   LIST
0385   2297 F6 28               .WORD   CLEAR
0386   2299 9E 29               .WORD   REM
0387   229B 9E 29               .WORD   REM
0388   229D B9 24               .WORD   NEW
0389   229F             
0390   229F             ; RESERVED WORD TOKEN VALUES
0391   229F             
0392   229F             ZEND    .EQU    080H            ; END
0393   229F             ZFOR    .EQU    081H            ; FOR
0394   229F             ZDATA   .EQU    083H            ; DATA
0395   229F             ZGOTO   .EQU    088H            ; GOTO
0396   229F             ZGOSUB  .EQU    08CH            ; GOSUB
0397   229F             ZREM    .EQU    08EH            ; REM
0398   229F             ZPRINT  .EQU    09EH            ; PRINT
0399   229F             ZNEW    .EQU    0A4H            ; NEW
0400   229F             
0401   229F             ZTAB    .EQU    0A5H            ; TAB
0402   229F             ZTO     .EQU    0A6H            ; TO
0403   229F             ZFN     .EQU    0A7H            ; FN
0404   229F             ZSPC    .EQU    0A8H            ; SPC
0405   229F             ZTHEN   .EQU    0A9H            ; THEN
0406   229F             ZNOT    .EQU    0AAH            ; NOT
0407   229F             ZSTEP   .EQU    0ABH            ; STEP
0408   229F             
0409   229F             ZPLUS   .EQU    0ACH            ; +
0410   229F             ZMINUS  .EQU    0ADH            ; -
0411   229F             ZTIMES  .EQU    0AEH            ; *
0412   229F             ZDIV    .EQU    0AFH            ; /
0413   229F             ZOR     .EQU    0B2H            ; OR
0414   229F             ZGTR    .EQU    0B3H            ; >
0415   229F             ZEQUAL  .EQU    0B4H            ; M
0416   229F             ZLTH    .EQU    0B5H            ; <
0417   229F             ZSGN    .EQU    0B6H            ; SGN
0418   229F             ZPOINT  .EQU    0C7H            ; POINT
0419   229F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0420   229F             
0421   229F             ; ARITHMETIC PRECEDENCE TABLE
0422   229F             
0423   229F 79          PRITAB: .BYTE   79H             ; Precedence value
0424   22A0 D5 37               .WORD   PADD            ; FPREG = <last> + FPREG
0425   22A2             
0426   22A2 79                  .BYTE   79H             ; Precedence value
0427   22A3 09 34               .WORD   PSUB            ; FPREG = <last> - FPREG
0428   22A5             
0429   22A5 7C                  .BYTE   7CH             ; Precedence value
0430   22A6 47 35               .WORD   MULT            ; PPREG = <last> * FPREG
0431   22A8             
0432   22A8 7C                  .BYTE   7CH             ; Precedence value
0433   22A9 A8 35               .WORD   DIV             ; FPREG = <last> / FPREG
0434   22AB             
0435   22AB 7F                  .BYTE   7FH             ; Precedence value
0436   22AC F6 38               .WORD   POWER           ; FPREG = <last> ^ FPREG
0437   22AE             
0438   22AE 50                  .BYTE   50H             ; Precedence value
0439   22AF BC 2D               .WORD   PAND            ; FPREG = <last> AND FPREG
0440   22B1             
0441   22B1 46                  .BYTE   46H             ; Precedence value
0442   22B2 BB 2D               .WORD   POR             ; FPREG = <last> OR FPREG
0443   22B4             
0444   22B4             ; BASIC ERROR CODE LIST
0445   22B4             
0446   22B4 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0447   22B6 53 4E               .BYTE   "SN"            ; Syntax error
0448   22B8 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0449   22BA 4F 44               .BYTE   "OD"            ; Out of DATA
0450   22BC 46 43               .BYTE   "FC"            ; Illegal function call
0451   22BE 4F 56               .BYTE   "OV"            ; Overflow error
0452   22C0 4F 4D               .BYTE   "OM"            ; Out of memory
0453   22C2 55 4C               .BYTE   "UL"            ; Undefined line
0454   22C4 42 53               .BYTE   "BS"            ; Bad subscript
0455   22C6 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0456   22C8 2F 30               .BYTE   "/0"            ; Division by zero
0457   22CA 49 44               .BYTE   "ID"            ; Illegal direct
0458   22CC 54 4D               .BYTE   "TM"            ; Type mis-match
0459   22CE 4F 53               .BYTE   "OS"            ; Out of string space
0460   22D0 4C 53               .BYTE   "LS"            ; String too long
0461   22D2 53 54               .BYTE   "ST"            ; String formula too complex
0462   22D4 43 4E               .BYTE   "CN"            ; Can't CONTinue
0463   22D6 55 46               .BYTE   "UF"            ; Undefined FN function
0464   22D8 4D 4F               .BYTE   "MO"            ; Missing operand
0465   22DA 48 58               .BYTE   "HX"            ; HEX error
0466   22DC 42 4E               .BYTE   "BN"            ; BIN error
0467   22DE             
0468   22DE             ; INITIALISATION TABLE -------------------------------------------------------
0469   22DE             
0470   22DE C3 A4 20    INITAB: JP      WARMST          ; Warm start jump
0471   22E1 C3 CC 28            JP      FCERR           ; "USR (X)" jump (Set to Error)
0472   22E4 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0473   22E6 C9                  RET
0474   22E7 D6 00               SUB     0               ; Division support routine
0475   22E9 6F                  LD      L,A
0476   22EA 7C                  LD      A,H
0477   22EB DE 00               SBC     A,0
0478   22ED 67                  LD      H,A
0479   22EE 78                  LD      A,B
0480   22EF DE 00               SBC     A,0
0481   22F1 47                  LD      B,A
0482   22F2 3E 00               LD      A,0
0483   22F4 C9                  RET
0484   22F5 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0485   22F8 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0486   22FC 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0487   2300 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0488   2304 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0489   2308 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0490   230C 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0491   2310 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0492   2314 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0493   2318 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0494   231C DB 00               IN      A,(0)           ; INP (x) skeleton
0495   231E C9                  RET
0496   231F 01                  .BYTE   1               ; POS (x) number (1)
0497   2320 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0498   2321 1C                  .BYTE   28              ; Width for commas (3 columns)
0499   2322 00                  .BYTE   0               ; No nulls after input bytes
0500   2323 00                  .BYTE   0               ; Output enabled (^O off)
0501   2324 14 00               .WORD   20              ; Initial lines counter
0502   2326 14 00               .WORD   20              ; Initial lines number
0503   2328 00 00               .WORD   0               ; Array load/save check sum
0504   232A 00                  .BYTE   0               ; Break not by NMI
0505   232B 00                  .BYTE   0               ; Break flag
0506   232C C3 F2 25            JP      TTYLIN          ; Input reflection (set to TTY)
0507   232F C3 00 00            JP      $0000           ; POINT reflection unused
0508   2332 C3 00 00            JP      $0000           ; SET reflection
0509   2335 C3 00 00            JP      $0000          	; RESET reflection
0510   2338 ED 41               .WORD   STLOOK          ; Temp string space
0511   233A FE FF               .WORD   -2              ; Current line number (cold)
0512   233C 8A 41               .WORD   PROGST+1        ; Start of program text
0513   233E             INITBE:                         
0514   233E             
0515   233E             ; END OF INITIALISATION TABLE ---------------------------------------------------
0516   233E             
0517   233E 204572726F72ERRMSG: .BYTE   " Error",0
0517   2344 00
0518   2345 20696E2000  INMSG:  .BYTE   " in ",0
0519   234A             ZERBYT  .EQU    $-1             ; A zero byte
0520   234A 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
0521   2350 427265616B00BRKMSG: .BYTE   "Break",0
0522   2356             
0523   2356 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0524   2359 39                  ADD     HL,SP           ; same index as specified
0525   235A 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0526   235B 23                  INC     HL              ; Point to index address
0527   235C FE 81               CP      ZFOR            ; Is it a "FOR" token
0528   235E C0                  RET     NZ              ; No - exit
0529   235F 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0530   2360 23                  INC     HL
0531   2361 46                  LD      B,(HL)
0532   2362 23                  INC     HL              ; Point to sign of STEP
0533   2363 E5                  PUSH    HL              ; Save pointer to sign
0534   2364 69                  LD      L,C             ; HL = address of "FOR" index
0535   2365 60                  LD      H,B
0536   2366 7A                  LD      A,D             ; See if an index was specified
0537   2367 B3                  OR      E               ; DE = 0 if no index specified
0538   2368 EB                  EX      DE,HL           ; Specified index into HL
0539   2369 CA 70 23            JP      Z,INDFND        ; Skip if no index given
0540   236C EB                  EX      DE,HL           ; Index back into DE
0541   236D CD 75 26            CALL    CPDEHL          ; Compare index with one given
0542   2370 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0543   2373 E1                  POP     HL              ; Restore pointer to sign
0544   2374 C8                  RET     Z               ; Return if block found
0545   2375 09                  ADD     HL,BC           ; Point to next block
0546   2376 C3 5A 23            JP      LOKFOR          ; Keep on looking
0547   2379             
0548   2379 CD 93 23    MOVUP:  CALL    ENFMEM          ; See if enough memory
0549   237C C5          MOVSTR: PUSH    BC              ; Save end of source
0550   237D E3                  EX      (SP),HL         ; Swap source and dest" end
0551   237E C1                  POP     BC              ; Get end of destination
0552   237F CD 75 26    MOVLP:  CALL    CPDEHL          ; See if list moved
0553   2382 7E                  LD      A,(HL)          ; Get byte
0554   2383 02                  LD      (BC),A          ; Move it
0555   2384 C8                  RET     Z               ; Exit if all done
0556   2385 0B                  DEC     BC              ; Next byte to move to
0557   2386 2B                  DEC     HL              ; Next byte to move
0558   2387 C3 7F 23            JP      MOVLP           ; Loop until all bytes moved
0559   238A             
0560   238A E5          CHKSTK: PUSH    HL              ; Save code string address
0561   238B 2A 6A 41            LD      HL,(ARREND)     ; Lowest free memory
0562   238E 06 00               LD      B,0             ; BC = Number of levels to test
0563   2390 09                  ADD     HL,BC           ; 2 Bytes for each level
0564   2391 09                  ADD     HL,BC
0565   2392 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0566   2393 E5          ENFMEM: PUSH    HL              ; Save code string address
0567   2394 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0568   2396 95                  SUB     L
0569   2397 6F                  LD      L,A
0570   2398 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0571   239A 9C                  SBC     A,H
0572   239B DA A2 23            JP      C,OMERR         ; Not enough - ?OM Error
0573   239E 67                  LD      H,A
0574   239F 39                  ADD     HL,SP           ; Test if stack is overflowed
0575   23A0 E1                  POP     HL              ; Restore code string address
0576   23A1 D8                  RET     C               ; Return if enough mmory
0577   23A2 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0578   23A4 C3 C1 23            JP      ERROR
0579   23A7             
0580   23A7 2A 59 41    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0581   23AA 22 EC 40            LD      (LINEAT),HL     ; Save as current line
0582   23AD 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0583   23AF 01                  .BYTE   01H             ; Skip "LD E,DZ"
0584   23B0 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0585   23B2 01                  .BYTE   01H             ; Skip "LD E,NF"
0586   23B3 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0587   23B5 01                  .BYTE   01H             ; Skip "LD E,DD"
0588   23B6 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0589   23B8 01                  .BYTE   01H             ; Skip "LD E,UF"
0590   23B9 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0591   23BB 01                  .BYTE   01H             ; Skip "LD E,OV
0592   23BC 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0593   23BE 01                  .BYTE   01H             ; Skip "LD E,TM"
0594   23BF 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0595   23C1             
0596   23C1 CD DF 24    ERROR:  CALL    CLREG           ; Clear registers and stack
0597   23C4 32 D5 40            LD      (CTLOFG),A      ; Enable output (A is 0)
0598   23C7 CD A0 2A            CALL    STTLIN          ; Start new line
0599   23CA 21 B4 22            LD      HL,ERRORS       ; Point to error codes
0600   23CD 57                  LD      D,A             ; D = 0 (A is 0)
0601   23CE 3E 3F               LD      A,'?'
0602   23D0 CD 86 26            CALL    OUTC            ; Output '?'
0603   23D3 19                  ADD     HL,DE           ; Offset to correct error code
0604   23D4 7E                  LD      A,(HL)          ; First character
0605   23D5 CD 86 26            CALL    OUTC            ; Output it
0606   23D8 CD 05 28            CALL    GETCHR          ; Get next character
0607   23DB CD 86 26            CALL    OUTC            ; Output it
0608   23DE 21 3E 23            LD      HL,ERRMSG       ; "Error" message
0609   23E1 CD 4B 31    ERRIN:  CALL    PRS             ; Output message
0610   23E4 2A EC 40            LD      HL,(LINEAT)     ; Get line of error
0611   23E7 11 FE FF            LD      DE,-2           ; Cold start error if -2
0612   23EA CD 75 26            CALL    CPDEHL          ; See if cold start error
0613   23ED CA 11 20            JP      Z,CSTART        ; Cold start error - Restart
0614   23F0 7C                  LD      A,H             ; Was it a direct error?
0615   23F1 A5                  AND     L               ; Line = -1 if direct error
0616   23F2 3C                  INC     A
0617   23F3 C4 E6 37            CALL    NZ,LINEIN       ; No - output line of error
0618   23F6 3E                  .BYTE   3EH             ; Skip "POP BC"
0619   23F7 C1          POPNOK: POP     BC              ; Drop address in input buffer
0620   23F8             
0621   23F8 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0622   23F9 32 D5 40            LD      (CTLOFG),A      ; Enable output
0623   23FC CD A0 2A            CALL    STTLIN          ; Start new line
0624   23FF 21 4A 23            LD      HL,OKMSG        ; "Ok" message
0625   2402 CD 4B 31            CALL    PRS             ; Output "Ok"
0626   2405 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0627   2408 22 EC 40            LD      (LINEAT),HL     ; Save as current line
0628   240B CD F2 25            CALL    GETLIN          ; Get an input line
0629   240E DA 05 24            JP      C,GETCMD        ; Get line again if break
0630   2411 CD 05 28            CALL    GETCHR          ; Get first character
0631   2414 3C                  INC     A               ; Test if end of line
0632   2415 3D                  DEC     A               ; Without affecting Carry
0633   2416 CA 05 24            JP      Z,GETCMD        ; Nothing entered - Get another
0634   2419 F5                  PUSH    AF              ; Save Carry status
0635   241A CD D1 28            CALL    ATOH            ; Get line number into DE
0636   241D D5                  PUSH    DE              ; Save line number
0637   241E CD 09 25            CALL    CRUNCH          ; Tokenise rest of line
0638   2421 47                  LD      B,A             ; Length of tokenised line
0639   2422 D1                  POP     DE              ; Restore line number
0640   2423 F1                  POP     AF              ; Restore Carry
0641   2424 D2 E5 27            JP      NC,EXCUTE       ; No line number - Direct mode
0642   2427 D5                  PUSH    DE              ; Save line number
0643   2428 C5                  PUSH    BC              ; Save length of tokenised line
0644   2429 AF                  XOR     A
0645   242A 32 5C 41            LD      (LSTBIN),A      ; Clear last byte input
0646   242D CD 05 28            CALL    GETCHR          ; Get next character
0647   2430 B7                  OR      A               ; Set flags
0648   2431 F5                  PUSH    AF              ; And save them
0649   2432 CD 99 24            CALL    SRCHLN          ; Search for line number in DE
0650   2435 DA 3E 24            JP      C,LINFND        ; Jump if line found
0651   2438 F1                  POP     AF              ; Get status
0652   2439 F5                  PUSH    AF              ; And re-save
0653   243A CA 72 29            JP      Z,ULERR         ; Nothing after number - Error
0654   243D B7                  OR      A               ; Clear Carry
0655   243E C5          LINFND: PUSH    BC              ; Save address of line in prog
0656   243F D2 55 24            JP      NC,INEWLN       ; Line not found - Insert new
0657   2442 EB                  EX      DE,HL           ; Next line address in DE
0658   2443 2A 66 41            LD      HL,(PROGND)     ; End of program
0659   2446 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0660   2447 02                  LD      (BC),A
0661   2448 03                  INC     BC              ; Next destination
0662   2449 13                  INC     DE              ; Next source
0663   244A CD 75 26            CALL    CPDEHL          ; All done?
0664   244D C2 46 24            JP      NZ,SFTPRG       ; More to do
0665   2450 60                  LD      H,B             ; HL - New end of program
0666   2451 69                  LD      L,C
0667   2452 22 66 41            LD      (PROGND),HL     ; Update end of program
0668   2455             
0669   2455 D1          INEWLN: POP     DE              ; Get address of line,
0670   2456 F1                  POP     AF              ; Get status
0671   2457 CA 7C 24            JP      Z,SETPTR        ; No text - Set up pointers
0672   245A 2A 66 41            LD      HL,(PROGND)     ; Get end of program
0673   245D E3                  EX      (SP),HL         ; Get length of input line
0674   245E C1                  POP     BC              ; End of program to BC
0675   245F 09                  ADD     HL,BC           ; Find new end
0676   2460 E5                  PUSH    HL              ; Save new end
0677   2461 CD 79 23            CALL    MOVUP           ; Make space for line
0678   2464 E1                  POP     HL              ; Restore new end
0679   2465 22 66 41            LD      (PROGND),HL     ; Update end of program pointer
0680   2468 EB                  EX      DE,HL           ; Get line to move up in HL
0681   2469 74                  LD      (HL),H          ; Save MSB
0682   246A D1                  POP     DE              ; Get new line number
0683   246B 23                  INC     HL              ; Skip pointer
0684   246C 23                  INC     HL
0685   246D 73                  LD      (HL),E          ; Save LSB of line number
0686   246E 23                  INC     HL
0687   246F 72                  LD      (HL),D          ; Save MSB of line number
0688   2470 23                  INC     HL              ; To first byte in line
0689   2471 11 F1 40            LD      DE,BUFFER       ; Copy buffer to program
0690   2474 1A          MOVBUF: LD      A,(DE)          ; Get source
0691   2475 77                  LD      (HL),A          ; Save destinations
0692   2476 23                  INC     HL              ; Next source
0693   2477 13                  INC     DE              ; Next destination
0694   2478 B7                  OR      A               ; Done?
0695   2479 C2 74 24            JP      NZ,MOVBUF       ; No - Repeat
0696   247C CD C5 24    SETPTR: CALL    RUNFST          ; Set line pointers
0697   247F 23                  INC     HL              ; To LSB of pointer
0698   2480 EB                  EX      DE,HL           ; Address to DE
0699   2481 62          PTRLP:  LD      H,D             ; Address to HL
0700   2482 6B                  LD      L,E
0701   2483 7E                  LD      A,(HL)          ; Get LSB of pointer
0702   2484 23                  INC     HL              ; To MSB of pointer
0703   2485 B6                  OR      (HL)            ; Compare with MSB pointer
0704   2486 CA 05 24            JP      Z,GETCMD        ; Get command line if end
0705   2489 23                  INC     HL              ; To LSB of line number
0706   248A 23                  INC     HL              ; Skip line number
0707   248B 23                  INC     HL              ; Point to first byte in line
0708   248C AF                  XOR     A               ; Looking for 00 byte
0709   248D BE          FNDEND: CP      (HL)            ; Found end of line?
0710   248E 23                  INC     HL              ; Move to next byte
0711   248F C2 8D 24            JP      NZ,FNDEND       ; No - Keep looking
0712   2492 EB                  EX      DE,HL           ; Next line address to HL
0713   2493 73                  LD      (HL),E          ; Save LSB of pointer
0714   2494 23                  INC     HL
0715   2495 72                  LD      (HL),D          ; Save MSB of pointer
0716   2496 C3 81 24            JP      PTRLP           ; Do next line
0717   2499             
0718   2499 2A EE 40    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0719   249C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0720   249D 4D                  LD      C,L
0721   249E 7E                  LD      A,(HL)          ; Get address of next line
0722   249F 23                  INC     HL
0723   24A0 B6                  OR      (HL)            ; End of program found?
0724   24A1 2B                  DEC     HL
0725   24A2 C8                  RET     Z               ; Yes - Line not found
0726   24A3 23                  INC     HL
0727   24A4 23                  INC     HL
0728   24A5 7E                  LD      A,(HL)          ; Get LSB of line number
0729   24A6 23                  INC     HL
0730   24A7 66                  LD      H,(HL)          ; Get MSB of line number
0731   24A8 6F                  LD      L,A
0732   24A9 CD 75 26            CALL    CPDEHL          ; Compare with line in DE
0733   24AC 60                  LD      H,B             ; HL = Start of this line
0734   24AD 69                  LD      L,C
0735   24AE 7E                  LD      A,(HL)          ; Get LSB of next line address
0736   24AF 23                  INC     HL
0737   24B0 66                  LD      H,(HL)          ; Get MSB of next line address
0738   24B1 6F                  LD      L,A             ; Next line to HL
0739   24B2 3F                  CCF
0740   24B3 C8                  RET     Z               ; Lines found - Exit
0741   24B4 3F                  CCF
0742   24B5 D0                  RET     NC              ; Line not found,at line after
0743   24B6 C3 9C 24            JP      SRCHLP          ; Keep looking
0744   24B9             
0745   24B9 C0          NEW:    RET     NZ              ; Return if any more on line
0746   24BA 2A EE 40    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0747   24BD AF                  XOR     A               ; Set program area to empty
0748   24BE 77                  LD      (HL),A          ; Save LSB = 00
0749   24BF 23                  INC     HL
0750   24C0 77                  LD      (HL),A          ; Save MSB = 00
0751   24C1 23                  INC     HL
0752   24C2 22 66 41            LD      (PROGND),HL     ; Set program end
0753   24C5             
0754   24C5 2A EE 40    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0755   24C8 2B                  DEC     HL
0756   24C9             
0757   24C9 22 5E 41    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0758   24CC 2A 3F 41            LD      HL,(LSTRAM)     ; Get end of RAM
0759   24CF 22 53 41            LD      (STRBOT),HL     ; Clear string space
0760   24D2 AF                  XOR     A
0761   24D3 CD 15 28            CALL    RESTOR          ; Reset DATA pointers
0762   24D6 2A 66 41            LD      HL,(PROGND)     ; Get end of program
0763   24D9 22 68 41            LD      (VAREND),HL     ; Clear variables
0764   24DC 22 6A 41            LD      (ARREND),HL     ; Clear arrays
0765   24DF             
0766   24DF C1          CLREG:  POP     BC              ; Save return address
0767   24E0 2A EA 40            LD      HL,(STRSPC)     ; Get end of working RAN
0768   24E3 F9                  LD      SP,HL           ; Set stack
0769   24E4 21 43 41            LD      HL,TMSTPL       ; Temporary string pool
0770   24E7 22 41 41            LD      (TMSTPT),HL     ; Reset temporary string ptr
0771   24EA AF                  XOR     A               ; A = 00
0772   24EB 6F                  LD      L,A             ; HL = 0000
0773   24EC 67                  LD      H,A
0774   24ED 22 64 41            LD      (CONTAD),HL     ; No CONTinue
0775   24F0 32 5B 41            LD      (FORFLG),A      ; Clear FOR flag
0776   24F3 22 6E 41            LD      (FNRGNM),HL     ; Clear FN argument
0777   24F6 E5                  PUSH    HL              ; HL = 0000
0778   24F7 C5                  PUSH    BC              ; Put back return
0779   24F8 2A 5E 41    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0780   24FB C9                  RET                     ; Return to execution driver
0781   24FC             
0782   24FC 3E 3F       PROMPT: LD      A,'?'           ; '?'
0783   24FE CD 86 26            CALL    OUTC            ; Output character
0784   2501 3E 20               LD      A,' '           ; Space
0785   2503 CD 86 26            CALL    OUTC            ; Output character
0786   2506 C3 DE 40            JP      RINPUT          ; Get input line
0787   2509             
0788   2509 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0789   250A 32 3E 41            LD      (DATFLG),A      ; Reset literal flag
0790   250D 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0791   250F 11 F1 40            LD      DE,BUFFER       ; Start of input buffer
0792   2512 7E          CRNCLP: LD      A,(HL)          ; Get byte
0793   2513 FE 20               CP      ' '             ; Is it a space?
0794   2515 CA 91 25            JP      Z,MOVDIR        ; Yes - Copy direct
0795   2518 47                  LD      B,A             ; Save character
0796   2519 FE 22               CP      '"'             ; Is it a quote?
0797   251B CA B1 25            JP      Z,CPYLIT        ; Yes - Copy literal string
0798   251E B7                  OR      A               ; Is it end of buffer?
0799   251F CA B8 25            JP      Z,ENDBUF        ; Yes - End buffer
0800   2522 3A 3E 41            LD      A,(DATFLG)      ; Get data type
0801   2525 B7                  OR      A               ; Literal?
0802   2526 7E                  LD      A,(HL)          ; Get byte to copy
0803   2527 C2 91 25            JP      NZ,MOVDIR       ; Literal - Copy direct
0804   252A FE 3F               CP      '?'             ; Is it '?' short for PRINT
0805   252C 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0806   252E CA 91 25            JP      Z,MOVDIR        ; Yes - replace it
0807   2531 7E                  LD      A,(HL)          ; Get byte again
0808   2532 FE 30               CP      '0'             ; Is it less than '0'
0809   2534 DA 3C 25            JP      C,FNDWRD        ; Yes - Look for reserved words
0810   2537 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0811   2539 DA 91 25            JP      C,MOVDIR        ; Yes - copy it direct
0812   253C D5          FNDWRD: PUSH    DE              ; Look for reserved words
0813   253D 11 35 21            LD      DE,WORDS-1      ; Point to table
0814   2540 C5                  PUSH    BC              ; Save count
0815   2541 01 8D 25            LD      BC,RETNAD       ; Where to return to
0816   2544 C5                  PUSH    BC              ; Save return address
0817   2545 06 7F               LD      B,ZEND-1        ; First token value -1
0818   2547 7E                  LD      A,(HL)          ; Get byte
0819   2548 FE 61               CP      'a'             ; Less than 'a' ?
0820   254A DA 55 25            JP      C,SEARCH        ; Yes - search for words
0821   254D FE 7B               CP      'z'+1           ; Greater than 'z' ?
0822   254F D2 55 25            JP      NC,SEARCH       ; Yes - search for words
0823   2552 E6 5F               AND     01011111B       ; Force upper case
0824   2554 77                  LD      (HL),A          ; Replace byte
0825   2555 4E          SEARCH: LD      C,(HL)          ; Search for a word
0826   2556 EB                  EX      DE,HL
0827   2557 23          GETNXT: INC     HL              ; Get next reserved word
0828   2558 B6                  OR      (HL)            ; Start of word?
0829   2559 F2 57 25            JP      P,GETNXT        ; No - move on
0830   255C 04                  INC     B               ; Increment token value
0831   255D 7E                  LD      A, (HL)         ; Get byte from table
0832   255E E6 7F               AND     01111111B       ; Strip bit 7
0833   2560 C8                  RET     Z               ; Return if end of list
0834   2561 B9                  CP      C               ; Same character as in buffer?
0835   2562 C2 57 25            JP      NZ,GETNXT       ; No - get next word
0836   2565 EB                  EX      DE,HL
0837   2566 E5                  PUSH    HL              ; Save start of word
0838   2567             
0839   2567 13          NXTBYT: INC     DE              ; Look through rest of word
0840   2568 1A                  LD      A,(DE)          ; Get byte from table
0841   2569 B7                  OR      A               ; End of word ?
0842   256A FA 89 25            JP      M,MATCH         ; Yes - Match found
0843   256D 4F                  LD      C,A             ; Save it
0844   256E 78                  LD      A,B             ; Get token value
0845   256F FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0846   2571 C2 78 25            JP      NZ,NOSPC        ; No - Don't allow spaces
0847   2574 CD 05 28            CALL    GETCHR          ; Get next character
0848   2577 2B                  DEC     HL              ; Cancel increment from GETCHR
0849   2578 23          NOSPC:  INC     HL              ; Next byte
0850   2579 7E                  LD      A,(HL)          ; Get byte
0851   257A FE 61               CP      'a'             ; Less than 'a' ?
0852   257C DA 81 25            JP      C,NOCHNG        ; Yes - don't change
0853   257F E6 5F               AND     01011111B       ; Make upper case
0854   2581 B9          NOCHNG: CP      C               ; Same as in buffer ?
0855   2582 CA 67 25            JP      Z,NXTBYT        ; Yes - keep testing
0856   2585 E1                  POP     HL              ; Get back start of word
0857   2586 C3 55 25            JP      SEARCH          ; Look at next word
0858   2589             
0859   2589 48          MATCH:  LD      C,B             ; Word found - Save token value
0860   258A F1                  POP     AF              ; Throw away return
0861   258B EB                  EX      DE,HL
0862   258C C9                  RET                     ; Return to "RETNAD"
0863   258D EB          RETNAD: EX      DE,HL           ; Get address in string
0864   258E 79                  LD      A,C             ; Get token value
0865   258F C1                  POP     BC              ; Restore buffer length
0866   2590 D1                  POP     DE              ; Get destination address
0867   2591 23          MOVDIR: INC     HL              ; Next source in buffer
0868   2592 12                  LD      (DE),A          ; Put byte in buffer
0869   2593 13                  INC     DE              ; Move up buffer
0870   2594 0C                  INC     C               ; Increment length of buffer
0871   2595 D6 3A               SUB     ':'             ; End of statement?
0872   2597 CA 9F 25            JP      Z,SETLIT        ; Jump if multi-statement line
0873   259A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0874   259C C2 A2 25            JP      NZ,TSTREM       ; No - see if REM
0875   259F 32 3E 41    SETLIT: LD      (DATFLG),A      ; Set literal flag
0876   25A2 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0877   25A4 C2 12 25            JP      NZ,CRNCLP       ; No - Leave flag
0878   25A7 47                  LD      B,A             ; Copy rest of buffer
0879   25A8 7E          NXTCHR: LD      A,(HL)          ; Get byte
0880   25A9 B7                  OR      A               ; End of line ?
0881   25AA CA B8 25            JP      Z,ENDBUF        ; Yes - Terminate buffer
0882   25AD B8                  CP      B               ; End of statement ?
0883   25AE CA 91 25            JP      Z,MOVDIR        ; Yes - Get next one
0884   25B1 23          CPYLIT: INC     HL              ; Move up source string
0885   25B2 12                  LD      (DE),A          ; Save in destination
0886   25B3 0C                  INC     C               ; Increment length
0887   25B4 13                  INC     DE              ; Move up destination
0888   25B5 C3 A8 25            JP      NXTCHR          ; Repeat
0889   25B8             
0890   25B8 21 F0 40    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0891   25BB 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0892   25BC 13                  INC     DE
0893   25BD 12                  LD      (DE),A          ; A = 00
0894   25BE 13                  INC     DE
0895   25BF 12                  LD      (DE),A          ; A = 00
0896   25C0 C9                  RET
0897   25C1             
0898   25C1 3A D4 40    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0899   25C4 B7                  OR      A               ; Is it zero?
0900   25C5 3E 00               LD      A,0             ; Zero A - Leave flags
0901   25C7 32 D4 40            LD      (NULFLG),A      ; Zero null flag
0902   25CA C2 D5 25            JP      NZ,ECHDEL       ; Set - Echo it
0903   25CD 05                  DEC     B               ; Decrement length
0904   25CE CA F2 25            JP      Z,GETLIN        ; Get line again if empty
0905   25D1 CD 86 26            CALL    OUTC            ; Output null character
0906   25D4 3E                  .BYTE   3EH             ; Skip "DEC B"
0907   25D5 05          ECHDEL: DEC     B               ; Count bytes in buffer
0908   25D6 2B                  DEC     HL              ; Back space buffer
0909   25D7 CA E9 25            JP      Z,OTKLN         ; No buffer - Try again
0910   25DA 7E                  LD      A,(HL)          ; Get deleted byte
0911   25DB CD 86 26            CALL    OUTC            ; Echo it
0912   25DE C3 FB 25            JP      MORINP          ; Get more input
0913   25E1             
0914   25E1 05          DELCHR: DEC     B               ; Count bytes in buffer
0915   25E2 2B                  DEC     HL              ; Back space buffer
0916   25E3 CD 86 26            CALL    OUTC            ; Output character in A
0917   25E6 C2 FB 25            JP      NZ,MORINP       ; Not end - Get more
0918   25E9 CD 86 26    OTKLN:  CALL    OUTC            ; Output character in A
0919   25EC CD AD 2A    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0920   25EF C3 F2 25            JP      TTYLIN          ; Get line again
0921   25F2             
0922   25F2             GETLIN:
0923   25F2 21 F1 40    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0924   25F5 06 01               LD      B,1             ; Set buffer as empty
0925   25F7 AF                  XOR     A
0926   25F8 32 D4 40            LD      (NULFLG),A      ; Clear null flag
0927   25FB CD B0 26    MORINP: CALL    CLOTST          ; Get character and test ^O
0928   25FE 4F                  LD      C,A             ; Save character in C
0929   25FF FE 7F               CP      DEL             ; Delete character?
0930   2601 CA C1 25            JP      Z,DODEL         ; Yes - Process it
0931   2604 3A D4 40            LD      A,(NULFLG)      ; Get null flag
0932   2607 B7                  OR      A               ; Test null flag status
0933   2608 CA 14 26            JP      Z,PROCES        ; Reset - Process character
0934   260B 3E 00               LD      A,0             ; Set a null
0935   260D CD 86 26            CALL    OUTC            ; Output null
0936   2610 AF                  XOR     A               ; Clear A
0937   2611 32 D4 40            LD      (NULFLG),A      ; Reset null flag
0938   2614 79          PROCES: LD      A,C             ; Get character
0939   2615 FE 07               CP      CTRLG           ; Bell?
0940   2617 CA 58 26            JP      Z,PUTCTL        ; Yes - Save it
0941   261A FE 03               CP      CTRLC           ; Is it control "C"?
0942   261C CC AD 2A            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0943   261F 37                  SCF                     ; Flag break
0944   2620 C8                  RET     Z               ; Return if control "C"
0945   2621 FE 0D               CP      CR              ; Is it enter?
0946   2623 CA A8 2A            JP      Z,ENDINP        ; Yes - Terminate input
0947   2626 FE 15               CP      CTRLU           ; Is it control "U"?
0948   2628 CA EC 25            JP      Z,KILIN         ; Yes - Get another line
0949   262B FE 40               CP      '@'             ; Is it "kill line"?
0950   262D CA E9 25            JP      Z,OTKLN         ; Yes - Kill line
0951   2630 FE 5F               CP      '_'             ; Is it delete?
0952   2632 CA E1 25            JP      Z,DELCHR        ; Yes - Delete character
0953   2635 FE 08               CP      BKSP            ; Is it backspace?
0954   2637 CA E1 25            JP      Z,DELCHR        ; Yes - Delete character
0955   263A FE 12               CP      CTRLR           ; Is it control "R"?
0956   263C C2 53 26            JP      NZ,PUTBUF       ; No - Put in buffer
0957   263F C5                  PUSH    BC              ; Save buffer length
0958   2640 D5                  PUSH    DE              ; Save DE
0959   2641 E5                  PUSH    HL              ; Save buffer address
0960   2642 36 00               LD      (HL),0          ; Mark end of buffer
0961   2644 CD 5D 3C            CALL    OUTNCR          ; Output and do CRLF
0962   2647 21 F1 40            LD      HL,BUFFER       ; Point to buffer start
0963   264A CD 4B 31            CALL    PRS             ; Output buffer
0964   264D E1                  POP     HL              ; Restore buffer address
0965   264E D1                  POP     DE              ; Restore DE
0966   264F C1                  POP     BC              ; Restore buffer length
0967   2650 C3 FB 25            JP      MORINP          ; Get another character
0968   2653             
0969   2653 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0970   2655 DA FB 25            JP      C,MORINP        ; Yes - Ignore
0971   2658 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0972   2659 FE 49               CP      72+1            ; Test for line overflow
0973   265B 3E 07               LD      A,CTRLG         ; Set a bell
0974   265D D2 6D 26            JP      NC,OUTNBS       ; Ring bell if buffer full
0975   2660 79                  LD      A,C             ; Get character
0976   2661 71                  LD      (HL),C          ; Save in buffer
0977   2662 32 5C 41            LD      (LSTBIN),A      ; Save last input byte
0978   2665 23                  INC     HL              ; Move up buffer
0979   2666 04                  INC     B               ; Increment length
0980   2667 CD 86 26    OUTIT:  CALL    OUTC            ; Output the character entered
0981   266A C3 FB 25            JP      MORINP          ; Get another character
0982   266D             
0983   266D CD 86 26    OUTNBS: CALL    OUTC            ; Output bell and back over it
0984   2670 3E 08               LD      A,BKSP          ; Set back space
0985   2672 C3 67 26            JP      OUTIT           ; Output it and get more
0986   2675             
0987   2675 7C          CPDEHL: LD      A,H             ; Get H
0988   2676 92                  SUB     D               ; Compare with D
0989   2677 C0                  RET     NZ              ; Different - Exit
0990   2678 7D                  LD      A,L             ; Get L
0991   2679 93                  SUB     E               ; Compare with E
0992   267A C9                  RET                     ; Return status
0993   267B             
0994   267B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0995   267C E3                  EX      (SP),HL         ; Address of test byte
0996   267D BE                  CP      (HL)            ; Same as in code string?
0997   267E 23                  INC     HL              ; Return address
0998   267F E3                  EX      (SP),HL         ; Put it back
0999   2680 CA 05 28            JP      Z,GETCHR        ; Yes - Get next character
1000   2683 C3 AD 23            JP      SNERR           ; Different - ?SN Error
1001   2686             
1002   2686 F5          OUTC:   PUSH    AF              ; Save character
1003   2687 3A D5 40            LD      A,(CTLOFG)      ; Get control "O" flag
1004   268A B7                  OR      A               ; Is it set?
1005   268B C2 80 31            JP      NZ,POPAF        ; Yes - don't output
1006   268E F1                  POP     AF              ; Restore character
1007   268F C5                  PUSH    BC              ; Save buffer length
1008   2690 F5                  PUSH    AF              ; Save character
1009   2691 FE 20               CP      ' '             ; Is it a control code?
1010   2693 DA AA 26            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1011   2696 3A D2 40            LD      A,(LWIDTH)      ; Get line width
1012   2699 47                  LD      B,A             ; To B
1013   269A 3A 3B 41            LD      A,(CURPOS)      ; Get cursor position
1014   269D 04                  INC     B               ; Width 255?
1015   269E CA A6 26            JP      Z,INCLEN        ; Yes - No width limit
1016   26A1 05                  DEC     B               ; Restore width
1017   26A2 B8                  CP      B               ; At end of line?
1018   26A3 CC AD 2A            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1019   26A6 3C          INCLEN: INC     A               ; Move on one character
1020   26A7 32 3B 41            LD      (CURPOS),A      ; Save new position
1021   26AA F1          DINPOS: POP     AF              ; Restore character
1022   26AB C1                  POP     BC              ; Restore buffer length
1023   26AC CD 46 3C            CALL    MONOUT          ; Send it
1024   26AF C9                  RET
1025   26B0             
1026   26B0 CD 0A 3B    CLOTST: CALL    GETINP          ; Get input character
1027   26B3 E6 7F               AND     01111111B       ; Strip bit 7
1028   26B5 FE 0F               CP      CTRLO           ; Is it control "O"?
1029   26B7 C0                  RET     NZ              ; No don't flip flag
1030   26B8 3A D5 40            LD      A,(CTLOFG)      ; Get flag
1031   26BB 2F                  CPL                     ; Flip it
1032   26BC 32 D5 40            LD      (CTLOFG),A      ; Put it back
1033   26BF AF                  XOR     A               ; Null character
1034   26C0 C9                  RET
1035   26C1             
1036   26C1 CD D1 28    LIST:   CALL    ATOH            ; ASCII number to DE
1037   26C4 C0                  RET     NZ              ; Return if anything extra
1038   26C5 C1                  POP     BC              ; Rubbish - Not needed
1039   26C6 CD 99 24            CALL    SRCHLN          ; Search for line number in DE
1040   26C9 C5                  PUSH    BC              ; Save address of line
1041   26CA CD 17 27            CALL    SETLIN          ; Set up lines counter
1042   26CD E1          LISTLP: POP     HL              ; Restore address of line
1043   26CE 4E                  LD      C,(HL)          ; Get LSB of next line
1044   26CF 23                  INC     HL
1045   26D0 46                  LD      B,(HL)          ; Get MSB of next line
1046   26D1 23                  INC     HL
1047   26D2 78                  LD      A,B             ; BC = 0 (End of program)?
1048   26D3 B1                  OR      C
1049   26D4 CA F8 23            JP      Z,PRNTOK        ; Yes - Go to command mode
1050   26D7 CD 20 27            CALL    COUNT           ; Count lines
1051   26DA CD 30 28            CALL    TSTBRK          ; Test for break key
1052   26DD C5                  PUSH    BC              ; Save address of next line
1053   26DE CD AD 2A            CALL    PRNTCRLF        ; Output CRLF
1054   26E1 5E                  LD      E,(HL)          ; Get LSB of line number
1055   26E2 23                  INC     HL
1056   26E3 56                  LD      D,(HL)          ; Get MSB of line number
1057   26E4 23                  INC     HL
1058   26E5 E5                  PUSH    HL              ; Save address of line start
1059   26E6 EB                  EX      DE,HL           ; Line number to HL
1060   26E7 CD EE 37            CALL    PRNTHL          ; Output line number in decimal
1061   26EA 3E 20               LD      A,' '           ; Space after line number
1062   26EC E1                  POP     HL              ; Restore start of line address
1063   26ED CD 86 26    LSTLP2: CALL    OUTC            ; Output character in A
1064   26F0 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1065   26F1 B7                  OR      A               ; End of line?
1066   26F2 23                  INC     HL              ; To next byte in line
1067   26F3 CA CD 26            JP      Z,LISTLP        ; Yes - get next line
1068   26F6 F2 ED 26            JP      P,LSTLP2        ; No token - output it
1069   26F9 D6 7F               SUB     ZEND-1          ; Find and output word
1070   26FB 4F                  LD      C,A             ; Token offset+1 to C
1071   26FC 11 36 21            LD      DE,WORDS        ; Reserved word list
1072   26FF 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1073   2700 13                  INC     DE              ; Move on to next
1074   2701 B7                  OR      A               ; Is it start of word?
1075   2702 F2 FF 26            JP      P,FNDTOK        ; No - Keep looking for word
1076   2705 0D                  DEC     C               ; Count words
1077   2706 C2 FF 26            JP      NZ,FNDTOK       ; Not there - keep looking
1078   2709 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1079   270B CD 86 26            CALL    OUTC            ; Output first character
1080   270E 1A                  LD      A,(DE)          ; Get next character
1081   270F 13                  INC     DE              ; Move on to next
1082   2710 B7                  OR      A               ; Is it end of word?
1083   2711 F2 09 27            JP      P,OUTWRD        ; No - output the rest
1084   2714 C3 F0 26            JP      LSTLP3          ; Next byte in line
1085   2717             
1086   2717 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1087   2718 2A D8 40            LD      HL,(LINESN)     ; Get LINES number
1088   271B 22 D6 40            LD      (LINESC),HL     ; Save in LINES counter
1089   271E E1                  POP     HL
1090   271F C9                  RET
1091   2720             
1092   2720 E5          COUNT:  PUSH    HL              ; Save code string address
1093   2721 D5                  PUSH    DE
1094   2722 2A D6 40            LD      HL,(LINESC)     ; Get LINES counter
1095   2725 11 FF FF            LD      DE,-1
1096   2728 ED 5A               ADC     HL,DE           ; Decrement
1097   272A 22 D6 40            LD      (LINESC),HL     ; Put it back
1098   272D D1                  POP     DE
1099   272E E1                  POP     HL              ; Restore code string address
1100   272F F0                  RET     P               ; Return if more lines to go
1101   2730 E5                  PUSH    HL              ; Save code string address
1102   2731 2A D8 40            LD      HL,(LINESN)     ; Get LINES number
1103   2734 22 D6 40            LD      (LINESC),HL     ; Reset LINES counter
1104   2737 CD 0A 3B            CALL    GETINP          ; Get input character
1105   273A FE 03               CP      CTRLC           ; Is it control "C"?
1106   273C CA 43 27            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1107   273F E1                  POP     HL              ; Restore code string address
1108   2740 C3 20 27            JP      COUNT           ; Keep on counting
1109   2743             
1110   2743 2A D8 40    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1111   2746 22 D6 40            LD      (LINESC),HL     ; Reset LINES counter
1112   2749 C3 A7 20            JP      BRKRET          ; Go and output "Break"
1113   274C             
1114   274C 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1115   274E 32 5B 41            LD      (FORFLG),A      ; Save "FOR" flag
1116   2751 CD B3 29            CALL    LET             ; Set up initial index
1117   2754 C1                  POP     BC              ; Drop RETurn address
1118   2755 E5                  PUSH    HL              ; Save code string address
1119   2756 CD 9C 29            CALL    DATA            ; Get next statement address
1120   2759 22 57 41            LD      (LOOPST),HL     ; Save it for start of loop
1121   275C 21 02 00            LD      HL,2            ; Offset for "FOR" block
1122   275F 39                  ADD     HL,SP           ; Point to it
1123   2760 CD 5A 23    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1124   2763 D1                  POP     DE              ; Get code string address
1125   2764 C2 7C 27            JP      NZ,FORFND       ; No nesting found
1126   2767 09                  ADD     HL,BC           ; Move into "FOR" block
1127   2768 D5                  PUSH    DE              ; Save code string address
1128   2769 2B                  DEC     HL
1129   276A 56                  LD      D,(HL)          ; Get MSB of loop statement
1130   276B 2B                  DEC     HL
1131   276C 5E                  LD      E,(HL)          ; Get LSB of loop statement
1132   276D 23                  INC     HL
1133   276E 23                  INC     HL
1134   276F E5                  PUSH    HL              ; Save block address
1135   2770 2A 57 41            LD      HL,(LOOPST)     ; Get address of loop statement
1136   2773 CD 75 26            CALL    CPDEHL          ; Compare the FOR loops
1137   2776 E1                  POP     HL              ; Restore block address
1138   2777 C2 60 27            JP      NZ,FORSLP       ; Different FORs - Find another
1139   277A D1                  POP     DE              ; Restore code string address
1140   277B F9                  LD      SP,HL           ; Remove all nested loops
1141   277C             
1142   277C EB          FORFND: EX      DE,HL           ; Code string address to HL
1143   277D 0E 08               LD      C,8
1144   277F CD 8A 23            CALL    CHKSTK          ; Check for 8 levels of stack
1145   2782 E5                  PUSH    HL              ; Save code string address
1146   2783 2A 57 41            LD      HL,(LOOPST)     ; Get first statement of loop
1147   2786 E3                  EX      (SP),HL         ; Save and restore code string
1148   2787 E5                  PUSH    HL              ; Re-save code string address
1149   2788 2A EC 40            LD      HL,(LINEAT)     ; Get current line number
1150   278B E3                  EX      (SP),HL         ; Save and restore code string
1151   278C CD 75 2C            CALL    TSTNUM          ; Make sure it's a number
1152   278F CD 7B 26            CALL    CHKSYN          ; Make sure "TO" is next
1153   2792 A6                  .BYTE   ZTO          ; "TO" token
1154   2793 CD 72 2C            CALL    GETNUM          ; Get "TO" expression value
1155   2796 E5                  PUSH    HL              ; Save code string address
1156   2797 CD A0 36            CALL    BCDEFP          ; Move "TO" value to BCDE
1157   279A E1                  POP     HL              ; Restore code string address
1158   279B C5                  PUSH    BC              ; Save "TO" value in block
1159   279C D5                  PUSH    DE
1160   279D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1161   27A0 51                  LD      D,C             ; C=0
1162   27A1 5A                  LD      E,D             ; D=0
1163   27A2 7E                  LD      A,(HL)          ; Get next byte in code string
1164   27A3 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1165   27A5 3E 01               LD      A,1             ; Sign of step = 1
1166   27A7 C2 B8 27            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1167   27AA CD 05 28            CALL    GETCHR          ; Jump over "STEP" token
1168   27AD CD 72 2C            CALL    GETNUM          ; Get step value
1169   27B0 E5                  PUSH    HL              ; Save code string address
1170   27B1 CD A0 36            CALL    BCDEFP          ; Move STEP to BCDE
1171   27B4 CD 54 36            CALL    TSTSGN          ; Test sign of FPREG
1172   27B7 E1                  POP     HL              ; Restore code string address
1173   27B8 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1174   27B9 D5                  PUSH    DE
1175   27BA F5                  PUSH    AF              ; Save sign of STEP
1176   27BB 33                  INC     SP              ; Don't save flags
1177   27BC E5                  PUSH    HL              ; Save code string address
1178   27BD 2A 5E 41            LD      HL,(BRKLIN)     ; Get address of index variable
1179   27C0 E3                  EX      (SP),HL         ; Save and restore code string
1180   27C1 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1181   27C3 C5                  PUSH    BC              ; Save it
1182   27C4 33                  INC     SP              ; Don't save C
1183   27C5             
1184   27C5 CD 30 28    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1185   27C8 22 5E 41            LD      (BRKLIN),HL     ; Save code address for break
1186   27CB 7E                  LD      A,(HL)          ; Get next byte in code string
1187   27CC FE 3A               CP      ':'             ; Multi statement line?
1188   27CE CA E5 27            JP      Z,EXCUTE        ; Yes - Execute it
1189   27D1 B7                  OR      A               ; End of line?
1190   27D2 C2 AD 23            JP      NZ,SNERR        ; No - Syntax error
1191   27D5 23                  INC     HL              ; Point to address of next line
1192   27D6 7E                  LD      A,(HL)          ; Get LSB of line pointer
1193   27D7 23                  INC     HL
1194   27D8 B6                  OR      (HL)            ; Is it zero (End of prog)?
1195   27D9 CA 57 28            JP      Z,ENDPRG        ; Yes - Terminate execution
1196   27DC 23                  INC     HL              ; Point to line number
1197   27DD 5E                  LD      E,(HL)          ; Get LSB of line number
1198   27DE 23                  INC     HL
1199   27DF 56                  LD      D,(HL)          ; Get MSB of line number
1200   27E0 EB                  EX      DE,HL           ; Line number to HL
1201   27E1 22 EC 40            LD      (LINEAT),HL     ; Save as current line number
1202   27E4 EB                  EX      DE,HL           ; Line number back to DE
1203   27E5 CD 05 28    EXCUTE: CALL    GETCHR          ; Get key word
1204   27E8 11 C5 27            LD      DE,RUNCNT       ; Where to RETurn to
1205   27EB D5                  PUSH    DE              ; Save for RETurn
1206   27EC C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1207   27ED D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1208   27EF DA B3 29            JP      C,LET           ; No - try to assign it
1209   27F2 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1210   27F4 D2 AD 23            JP      NC,SNERR        ; Not a key word - ?SN Error
1211   27F7 07                  RLCA                    ; Double it
1212   27F8 4F                  LD      C,A             ; BC = Offset into table
1213   27F9 06 00               LD      B,0
1214   27FB EB                  EX      DE,HL           ; Save code string address
1215   27FC 21 55 22            LD      HL,WORDTB       ; Keyword address table
1216   27FF 09                  ADD     HL,BC           ; Point to routine address
1217   2800 4E                  LD      C,(HL)          ; Get LSB of routine address
1218   2801 23                  INC     HL
1219   2802 46                  LD      B,(HL)          ; Get MSB of routine address
1220   2803 C5                  PUSH    BC              ; Save routine address
1221   2804 EB                  EX      DE,HL           ; Restore code string address
1222   2805             
1223   2805 23          GETCHR: INC     HL              ; Point to next character
1224   2806 7E                  LD      A,(HL)          ; Get next code string byte
1225   2807 FE 3A               CP      ':'             ; Z if ':'
1226   2809 D0                  RET     NC              ; NC if > "9"
1227   280A FE 20               CP      ' '
1228   280C CA 05 28            JP      Z,GETCHR        ; Skip over spaces
1229   280F FE 30               CP      '0'
1230   2811 3F                  CCF                     ; NC if < '0'
1231   2812 3C                  INC     A               ; Test for zero - Leave carry
1232   2813 3D                  DEC     A               ; Z if Null
1233   2814 C9                  RET
1234   2815             
1235   2815 EB          RESTOR: EX      DE,HL           ; Save code string address
1236   2816 2A EE 40            LD      HL,(BASTXT)     ; Point to start of program
1237   2819 CA 2A 28            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1238   281C EB                  EX      DE,HL           ; Restore code string address
1239   281D CD D1 28            CALL    ATOH            ; Get line number to DE
1240   2820 E5                  PUSH    HL              ; Save code string address
1241   2821 CD 99 24            CALL    SRCHLN          ; Search for line number in DE
1242   2824 60                  LD      H,B             ; HL = Address of line
1243   2825 69                  LD      L,C
1244   2826 D1                  POP     DE              ; Restore code string address
1245   2827 D2 72 29            JP      NC,ULERR        ; ?UL Error if not found
1246   282A 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1247   282B 22 6C 41    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1248   282E EB                  EX      DE,HL           ; Restore code string address
1249   282F C9                  RET
1250   2830             
1251   2830             
1252   2830 DF          TSTBRK: RST     18H             ; Check input status
1253   2831 C8                  RET     Z               ; No key, go back
1254   2832 D7                  RST     10H             ; Get the key into A
1255   2833 FE 1B               CP      ESC             ; Escape key?
1256   2835 28 11               JR      Z,BRK           ; Yes, break
1257   2837 FE 03               CP      CTRLC           ; <Ctrl-C>
1258   2839 28 0D               JR      Z,BRK           ; Yes, break
1259   283B FE 13               CP      CTRLS           ; Stop scrolling?
1260   283D C0                  RET     NZ              ; Other key, ignore
1261   283E             
1262   283E             
1263   283E D7          STALL:  RST     10H             ; Wait for key
1264   283F FE 11               CP      CTRLQ           ; Resume scrolling?
1265   2841 C8                  RET      Z              ; Release the chokehold
1266   2842 FE 03               CP      CTRLC           ; Second break?
1267   2844 28 07               JR      Z,STOP          ; Break during hold exits prog
1268   2846 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1269   2848             
1270   2848 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1271   284A 32 DD 40            LD      (BRKFLG),A      ; Store it
1272   284D             
1273   284D             
1274   284D C0          STOP:   RET     NZ              ; Exit if anything else
1275   284E F6                  .BYTE   0F6H            ; Flag "STOP"
1276   284F C0          PEND:   RET     NZ              ; Exit if anything else
1277   2850 22 5E 41            LD      (BRKLIN),HL     ; Save point of break
1278   2853 21                  .BYTE   21H             ; Skip "OR 11111111B"
1279   2854 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1280   2856 C1                  POP     BC              ; Return not needed and more
1281   2857 2A EC 40    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1282   285A F5                  PUSH    AF              ; Save STOP / END status
1283   285B 7D                  LD      A,L             ; Is it direct break?
1284   285C A4                  AND     H
1285   285D 3C                  INC     A               ; Line is -1 if direct break
1286   285E CA 6A 28            JP      Z,NOLIN         ; Yes - No line number
1287   2861 22 62 41            LD      (ERRLIN),HL     ; Save line of break
1288   2864 2A 5E 41            LD      HL,(BRKLIN)     ; Get point of break
1289   2867 22 64 41            LD      (CONTAD),HL     ; Save point to CONTinue
1290   286A AF          NOLIN:  XOR     A
1291   286B 32 D5 40            LD      (CTLOFG),A      ; Enable output
1292   286E CD A0 2A            CALL    STTLIN          ; Start a new line
1293   2871 F1                  POP     AF              ; Restore STOP / END status
1294   2872 21 50 23            LD      HL,BRKMSG       ; "Break" message
1295   2875 C2 E1 23            JP      NZ,ERRIN        ; "in line" wanted?
1296   2878 C3 F8 23            JP      PRNTOK          ; Go to command mode
1297   287B             
1298   287B 2A 64 41    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1299   287E 7C                  LD      A,H             ; Is it zero?
1300   287F B5                  OR      L
1301   2880 1E 20               LD      E,CN            ; ?CN Error
1302   2882 CA C1 23            JP      Z,ERROR         ; Yes - output "?CN Error"
1303   2885 EB                  EX      DE,HL           ; Save code string address
1304   2886 2A 62 41            LD      HL,(ERRLIN)     ; Get line of last break
1305   2889 22 EC 40            LD      (LINEAT),HL     ; Set up current line number
1306   288C EB                  EX      DE,HL           ; Restore code string address
1307   288D C9                  RET                     ; CONTinue where left off
1308   288E             
1309   288E CD D3 33    NULL:   CALL    GETINT          ; Get integer 0-255
1310   2891 C0                  RET     NZ              ; Return if bad value
1311   2892 32 D1 40            LD      (NULLS),A       ; Set nulls number
1312   2895 C9                  RET
1313   2896             
1314   2896             
1315   2896 E5          ACCSUM: PUSH    HL              ; Save address in array
1316   2897 2A DA 40            LD      HL,(CHKSUM)     ; Get check sum
1317   289A 06 00               LD      B,0             ; BC - Value of byte
1318   289C 4F                  LD      C,A
1319   289D 09                  ADD     HL,BC           ; Add byte to check sum
1320   289E 22 DA 40            LD      (CHKSUM),HL     ; Re-save check sum
1321   28A1 E1                  POP     HL              ; Restore address in array
1322   28A2 C9                  RET
1323   28A3             
1324   28A3 7E          CHKLTR: LD      A,(HL)          ; Get byte
1325   28A4 FE 41               CP      'A'             ; < 'a' ?
1326   28A6 D8                  RET     C               ; Carry set if not letter
1327   28A7 FE 5B               CP      'Z'+1           ; > 'z' ?
1328   28A9 3F                  CCF
1329   28AA C9                  RET                     ; Carry set if not letter
1330   28AB             
1331   28AB CD 05 28    FPSINT: CALL    GETCHR          ; Get next character
1332   28AE CD 72 2C    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1333   28B1 CD 54 36    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1334   28B4 FA CC 28            JP      M,FCERR         ; Negative - ?FC Error
1335   28B7 3A 77 41    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1336   28BA FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1337   28BC DA FC 36            JP      C,FPINT         ; Yes - convert it
1338   28BF 01 80 90            LD      BC,9080H        ; BCDE = -32768
1339   28C2 11 00 00            LD      DE,0000
1340   28C5 E5                  PUSH    HL              ; Save code string address
1341   28C6 CD CF 36            CALL    CMPNUM          ; Compare FPREG with BCDE
1342   28C9 E1                  POP     HL              ; Restore code string address
1343   28CA 51                  LD      D,C             ; MSB to D
1344   28CB C8                  RET     Z               ; Return if in range
1345   28CC 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1346   28CE C3 C1 23            JP      ERROR           ; Output error-
1347   28D1             
1348   28D1 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1349   28D2 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1350   28D5 CD 05 28    GTLNLP: CALL    GETCHR          ; Get next character
1351   28D8 D0                  RET     NC              ; Exit if not a digit
1352   28D9 E5                  PUSH    HL              ; Save code string address
1353   28DA F5                  PUSH    AF              ; Save digit
1354   28DB 21 98 19            LD      HL,65529/10     ; Largest number 65529
1355   28DE CD 75 26            CALL    CPDEHL          ; Number in range?
1356   28E1 DA AD 23            JP      C,SNERR         ; No - ?SN Error
1357   28E4 62                  LD      H,D             ; HL = Number
1358   28E5 6B                  LD      L,E
1359   28E6 19                  ADD     HL,DE           ; Times 2
1360   28E7 29                  ADD     HL,HL           ; Times 4
1361   28E8 19                  ADD     HL,DE           ; Times 5
1362   28E9 29                  ADD     HL,HL           ; Times 10
1363   28EA F1                  POP     AF              ; Restore digit
1364   28EB D6 30               SUB     '0'             ; Make it 0 to 9
1365   28ED 5F                  LD      E,A             ; DE = Value of digit
1366   28EE 16 00               LD      D,0
1367   28F0 19                  ADD     HL,DE           ; Add to number
1368   28F1 EB                  EX      DE,HL           ; Number to DE
1369   28F2 E1                  POP     HL              ; Restore code string address
1370   28F3 C3 D5 28            JP      GTLNLP          ; Go to next character
1371   28F6             
1372   28F6 CA C9 24    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1373   28F9 CD AE 28            CALL    POSINT          ; Get integer 0 to 32767 to DE
1374   28FC 2B                  DEC     HL              ; Cancel increment
1375   28FD CD 05 28            CALL    GETCHR          ; Get next character
1376   2900 E5                  PUSH    HL              ; Save code string address
1377   2901 2A 3F 41            LD      HL,(LSTRAM)     ; Get end of RAM
1378   2904 CA 19 29            JP      Z,STORED        ; No value given - Use stored
1379   2907 E1                  POP     HL              ; Restore code string address
1380   2908 CD 7B 26            CALL    CHKSYN          ; Check for comma
1381   290B 2C                  .BYTE      ','
1382   290C D5                  PUSH    DE              ; Save number
1383   290D CD AE 28            CALL    POSINT          ; Get integer 0 to 32767
1384   2910 2B                  DEC     HL              ; Cancel increment
1385   2911 CD 05 28            CALL    GETCHR          ; Get next character
1386   2914 C2 AD 23            JP      NZ,SNERR        ; ?SN Error if more on line
1387   2917 E3                  EX      (SP),HL         ; Save code string address
1388   2918 EB                  EX      DE,HL           ; Number to DE
1389   2919 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1390   291A 93                  SUB     E               ; Subtract LSB of string space
1391   291B 5F                  LD      E,A             ; Save LSB
1392   291C 7C                  LD      A,H             ; Get MSB of new RAM top
1393   291D 9A                  SBC     A,D             ; Subtract MSB of string space
1394   291E 57                  LD      D,A             ; Save MSB
1395   291F DA A2 23            JP      C,OMERR         ; ?OM Error if not enough mem
1396   2922 E5                  PUSH    HL              ; Save RAM top
1397   2923 2A 66 41            LD      HL,(PROGND)     ; Get program end
1398   2926 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1399   2929 09                  ADD     HL,BC           ; Get lowest address
1400   292A CD 75 26            CALL    CPDEHL          ; Enough memory?
1401   292D D2 A2 23            JP      NC,OMERR        ; No - ?OM Error
1402   2930 EB                  EX      DE,HL           ; RAM top to HL
1403   2931 22 EA 40            LD      (STRSPC),HL     ; Set new string space
1404   2934 E1                  POP     HL              ; End of memory to use
1405   2935 22 3F 41            LD      (LSTRAM),HL     ; Set new top of RAM
1406   2938 E1                  POP     HL              ; Restore code string address
1407   2939 C3 C9 24            JP      INTVAR          ; Initialise variables
1408   293C             
1409   293C CA C5 24    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1410   293F CD C9 24            CALL    INTVAR          ; Initialise variables
1411   2942 01 C5 27            LD      BC,RUNCNT       ; Execution driver loop
1412   2945 C3 58 29            JP      RUNLIN          ; RUN from line number
1413   2948             
1414   2948 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1415   294A CD 8A 23            CALL    CHKSTK          ; Check for 3 levels of stack
1416   294D C1                  POP     BC              ; Get return address
1417   294E E5                  PUSH    HL              ; Save code string for RETURN
1418   294F E5                  PUSH    HL              ; And for GOSUB routine
1419   2950 2A EC 40            LD      HL,(LINEAT)     ; Get current line
1420   2953 E3                  EX      (SP),HL         ; Into stack - Code string out
1421   2954 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1422   2956 F5                  PUSH    AF              ; Save token
1423   2957 33                  INC     SP              ; Don't save flags
1424   2958             
1425   2958 C5          RUNLIN: PUSH    BC              ; Save return address
1426   2959 CD D1 28    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1427   295C CD 9E 29            CALL    REM             ; Get end of line
1428   295F E5                  PUSH    HL              ; Save end of line
1429   2960 2A EC 40            LD      HL,(LINEAT)     ; Get current line
1430   2963 CD 75 26            CALL    CPDEHL          ; Line after current?
1431   2966 E1                  POP     HL              ; Restore end of line
1432   2967 23                  INC     HL              ; Start of next line
1433   2968 DC 9C 24            CALL    C,SRCHLP        ; Line is after current line
1434   296B D4 99 24            CALL    NC,SRCHLN       ; Line is before current line
1435   296E 60                  LD      H,B             ; Set up code string address
1436   296F 69                  LD      L,C
1437   2970 2B                  DEC     HL              ; Incremented after
1438   2971 D8                  RET     C               ; Line found
1439   2972 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1440   2974 C3 C1 23            JP      ERROR           ; Output error message
1441   2977             
1442   2977 C0          RETURN: RET     NZ              ; Return if not just RETURN
1443   2978 16 FF               LD      D,-1            ; Flag "GOSUB" search
1444   297A CD 56 23            CALL    BAKSTK          ; Look "GOSUB" block
1445   297D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1446   297E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1447   2980 1E 04               LD      E,RG            ; ?RG Error
1448   2982 C2 C1 23            JP      NZ,ERROR        ; Error if no "GOSUB" found
1449   2985 E1                  POP     HL              ; Get RETURN line number
1450   2986 22 EC 40            LD      (LINEAT),HL     ; Save as current
1451   2989 23                  INC     HL              ; Was it from direct statement?
1452   298A 7C                  LD      A,H
1453   298B B5                  OR      L               ; Return to line
1454   298C C2 96 29            JP      NZ,RETLIN       ; No - Return to line
1455   298F 3A 5C 41            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1456   2992 B7                  OR      A               ; If so buffer is corrupted
1457   2993 C2 F7 23            JP      NZ,POPNOK       ; Yes - Go to command mode
1458   2996 21 C5 27    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1459   2999 E3                  EX      (SP),HL         ; Into stack - Code string out
1460   299A 3E                  .BYTE      3EH             ; Skip "POP HL"
1461   299B E1          NXTDTA: POP     HL              ; Restore code string address
1462   299C             
1463   299C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1464   299E 0E 00       REM:    LD      C,0             ; 00  End of statement
1465   29A0 06 00               LD      B,0
1466   29A2 79          NXTSTL: LD      A,C             ; Statement and byte
1467   29A3 48                  LD      C,B
1468   29A4 47                  LD      B,A             ; Statement end byte
1469   29A5 7E          NXTSTT: LD      A,(HL)          ; Get byte
1470   29A6 B7                  OR      A               ; End of line?
1471   29A7 C8                  RET     Z               ; Yes - Exit
1472   29A8 B8                  CP      B               ; End of statement?
1473   29A9 C8                  RET     Z               ; Yes - Exit
1474   29AA 23                  INC     HL              ; Next byte
1475   29AB FE 22               CP      '"'             ; Literal string?
1476   29AD CA A2 29            JP      Z,NXTSTL        ; Yes - Look for another '"'
1477   29B0 C3 A5 29            JP      NXTSTT          ; Keep looking
1478   29B3             
1479   29B3 CD 68 2E    LET:    CALL    GETVAR          ; Get variable name
1480   29B6 CD 7B 26            CALL    CHKSYN          ; Make sure "=" follows
1481   29B9 B4                  .BYTE      ZEQUAL          ; "=" token
1482   29BA D5                  PUSH    DE              ; Save address of variable
1483   29BB 3A 3D 41            LD      A,(TYPE)        ; Get data type
1484   29BE F5                  PUSH    AF              ; Save type
1485   29BF CD 84 2C            CALL    EVAL            ; Evaluate expression
1486   29C2 F1                  POP     AF              ; Restore type
1487   29C3 E3                  EX      (SP),HL         ; Save code - Get var addr
1488   29C4 22 5E 41            LD      (BRKLIN),HL     ; Save address of variable
1489   29C7 1F                  RRA                     ; Adjust type
1490   29C8 CD 77 2C            CALL    CHKTYP          ; Check types are the same
1491   29CB CA 06 2A            JP      Z,LETNUM        ; Numeric - Move value
1492   29CE E5          LETSTR: PUSH    HL              ; Save address of string var
1493   29CF 2A 74 41            LD      HL,(FPREG)      ; Pointer to string entry
1494   29D2 E5                  PUSH    HL              ; Save it on stack
1495   29D3 23                  INC     HL              ; Skip over length
1496   29D4 23                  INC     HL
1497   29D5 5E                  LD      E,(HL)          ; LSB of string address
1498   29D6 23                  INC     HL
1499   29D7 56                  LD      D,(HL)          ; MSB of string address
1500   29D8 2A EE 40            LD      HL,(BASTXT)     ; Point to start of program
1501   29DB CD 75 26            CALL    CPDEHL          ; Is string before program?
1502   29DE D2 F5 29            JP      NC,CRESTR       ; Yes - Create string entry
1503   29E1 2A EA 40            LD      HL,(STRSPC)     ; Point to string space
1504   29E4 CD 75 26            CALL    CPDEHL          ; Is string literal in program?
1505   29E7 D1                  POP     DE              ; Restore address of string
1506   29E8 D2 FD 29            JP      NC,MVSTPT       ; Yes - Set up pointer
1507   29EB 21 4F 41            LD      HL,TMPSTR       ; Temporary string pool
1508   29EE CD 75 26            CALL    CPDEHL          ; Is string in temporary pool?
1509   29F1 D2 FD 29            JP      NC,MVSTPT       ; No - Set up pointer
1510   29F4 3E                  .BYTE   3EH             ; Skip "POP DE"
1511   29F5 D1          CRESTR: POP     DE              ; Restore address of string
1512   29F6 CD AC 32            CALL    BAKTMP          ; Back to last tmp-str entry
1513   29F9 EB                  EX      DE,HL           ; Address of string entry
1514   29FA CD E5 30            CALL    SAVSTR          ; Save string in string area
1515   29FD CD AC 32    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1516   2A00 E1                  POP     HL              ; Get string pointer
1517   2A01 CD AF 36            CALL    DETHL4          ; Move string pointer to var
1518   2A04 E1                  POP     HL              ; Restore code string address
1519   2A05 C9                  RET
1520   2A06             
1521   2A06 E5          LETNUM: PUSH    HL              ; Save address of variable
1522   2A07 CD AC 36            CALL    FPTHL           ; Move value to variable
1523   2A0A D1                  POP     DE              ; Restore address of variable
1524   2A0B E1                  POP     HL              ; Restore code string address
1525   2A0C C9                  RET
1526   2A0D             
1527   2A0D CD D3 33    ON:     CALL    GETINT          ; Get integer 0-255
1528   2A10 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1529   2A11 47                  LD      B,A             ; Save in B
1530   2A12 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1531   2A14 CA 1C 2A            JP      Z,ONGO          ; Yes - Find line number
1532   2A17 CD 7B 26            CALL    CHKSYN          ; Make sure it's "GOTO"
1533   2A1A 88                  .BYTE   ZGOTO           ; "GOTO" token
1534   2A1B 2B                  DEC     HL              ; Cancel increment
1535   2A1C 4B          ONGO:   LD      C,E             ; Integer of branch value
1536   2A1D 0D          ONGOLP: DEC     C               ; Count branches
1537   2A1E 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1538   2A1F CA ED 27            JP      Z,ONJMP         ; Go to that line if right one
1539   2A22 CD D2 28            CALL    GETLN           ; Get line number to DE
1540   2A25 FE 2C               CP      ','             ; Another line number?
1541   2A27 C0                  RET     NZ              ; No - Drop through
1542   2A28 C3 1D 2A            JP      ONGOLP          ; Yes - loop
1543   2A2B             
1544   2A2B CD 84 2C    IF:     CALL    EVAL            ; Evaluate expression
1545   2A2E 7E                  LD      A,(HL)          ; Get token
1546   2A2F FE 88               CP      ZGOTO           ; "GOTO" token?
1547   2A31 CA 39 2A            JP      Z,IFGO          ; Yes - Get line
1548   2A34 CD 7B 26            CALL    CHKSYN          ; Make sure it's "THEN"
1549   2A37 A9                  .BYTE      ZTHEN           ; "THEN" token
1550   2A38 2B                  DEC     HL              ; Cancel increment
1551   2A39 CD 75 2C    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1552   2A3C CD 54 36            CALL    TSTSGN          ; Test state of expression
1553   2A3F CA 9E 29            JP      Z,REM           ; False - Drop through
1554   2A42 CD 05 28            CALL    GETCHR          ; Get next character
1555   2A45 DA 59 29            JP      C,GOTO          ; Number - GOTO that line
1556   2A48 C3 EC 27            JP      IFJMP           ; Otherwise do statement
1557   2A4B             
1558   2A4B 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1559   2A4C CD 05 28            CALL    GETCHR          ; Get next character
1560   2A4F CA AD 2A    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1561   2A52 C8          PRNTLP: RET     Z               ; End of list - Exit
1562   2A53 FE A5               CP      ZTAB            ; "TAB(" token?
1563   2A55 CA E0 2A            JP      Z,DOTAB         ; Yes - Do TAB routine
1564   2A58 FE A8               CP      ZSPC            ; "SPC(" token?
1565   2A5A CA E0 2A            JP      Z,DOTAB         ; Yes - Do SPC routine
1566   2A5D E5                  PUSH    HL              ; Save code string address
1567   2A5E FE 2C               CP      ','             ; Comma?
1568   2A60 CA C9 2A            JP      Z,DOCOM         ; Yes - Move to next zone
1569   2A63 FE 3B               CP      59 ;";"         ; Semi-colon?
1570   2A65 CA 03 2B            JP      Z,NEXITM        ; Do semi-colon routine
1571   2A68 C1                  POP     BC              ; Code string address to BC
1572   2A69 CD 84 2C            CALL    EVAL            ; Evaluate expression
1573   2A6C E5                  PUSH    HL              ; Save code string address
1574   2A6D 3A 3D 41            LD      A,(TYPE)        ; Get variable type
1575   2A70 B7                  OR      A               ; Is it a string variable?
1576   2A71 C2 99 2A            JP      NZ,PRNTST       ; Yes - Output string contents
1577   2A74 CD F9 37            CALL    NUMASC          ; Convert number to text
1578   2A77 CD 09 31            CALL    CRTST           ; Create temporary string
1579   2A7A 36 20               LD      (HL),' '        ; Followed by a space
1580   2A7C 2A 74 41            LD      HL,(FPREG)      ; Get length of output
1581   2A7F 34                  INC     (HL)            ; Plus 1 for the space
1582   2A80 2A 74 41            LD      HL,(FPREG)      ; < Not needed >
1583   2A83 3A D2 40            LD      A,(LWIDTH)      ; Get width of line
1584   2A86 47                  LD      B,A             ; To B
1585   2A87 04                  INC     B               ; Width 255 (No limit)?
1586   2A88 CA 95 2A            JP      Z,PRNTNB        ; Yes - Output number string
1587   2A8B 04                  INC     B               ; Adjust it
1588   2A8C 3A 3B 41            LD      A,(CURPOS)      ; Get cursor position
1589   2A8F 86                  ADD     A,(HL)          ; Add length of string
1590   2A90 3D                  DEC     A               ; Adjust it
1591   2A91 B8                  CP      B               ; Will output fit on this line?
1592   2A92 D4 AD 2A            CALL    NC,PRNTCRLF     ; No - CRLF first
1593   2A95 CD 4E 31    PRNTNB: CALL    PRS1            ; Output string at (HL)
1594   2A98 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1595   2A99 C4 4E 31    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1596   2A9C E1                  POP     HL              ; Restore code string address
1597   2A9D C3 4B 2A            JP      MRPRNT          ; See if more to PRINT
1598   2AA0             
1599   2AA0 3A 3B 41    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1600   2AA3 B7                  OR      A               ; Already at start?
1601   2AA4 C8                  RET     Z               ; Yes - Do nothing
1602   2AA5 C3 AD 2A            JP      PRNTCRLF        ; Start a new line
1603   2AA8             
1604   2AA8 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1605   2AAA 21 F0 40            LD      HL,BUFFER-1     ; Point to buffer
1606   2AAD 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1607   2AAF CD 86 26            CALL    OUTC            ; Output character
1608   2AB2 3E 0A               LD      A,LF            ; Load a LF
1609   2AB4 CD 86 26            CALL    OUTC            ; Output character
1610   2AB7 AF          DONULL: XOR     A               ; Set to position 0
1611   2AB8 32 3B 41            LD      (CURPOS),A      ; Store it
1612   2ABB 3A D1 40            LD      A,(NULLS)       ; Get number of nulls
1613   2ABE 3D          NULLP:  DEC     A               ; Count them
1614   2ABF C8                  RET     Z               ; Return if done
1615   2AC0 F5                  PUSH    AF              ; Save count
1616   2AC1 AF                  XOR     A               ; Load a null
1617   2AC2 CD 86 26            CALL    OUTC            ; Output it
1618   2AC5 F1                  POP     AF              ; Restore count
1619   2AC6 C3 BE 2A            JP      NULLP           ; Keep counting
1620   2AC9             
1621   2AC9 3A D3 40    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1622   2ACC 47                  LD      B,A             ; Save in B
1623   2ACD 3A 3B 41            LD      A,(CURPOS)      ; Get current position
1624   2AD0 B8                  CP      B               ; Within the limit?
1625   2AD1 D4 AD 2A            CALL    NC,PRNTCRLF     ; No - output CRLF
1626   2AD4 D2 03 2B            JP      NC,NEXITM       ; Get next item
1627   2AD7 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1628   2AD9 D2 D7 2A            JP      NC,ZONELP       ; Repeat if more zones
1629   2ADC 2F                  CPL                     ; Number of spaces to output
1630   2ADD C3 F8 2A            JP      ASPCS           ; Output them
1631   2AE0             
1632   2AE0 F5          DOTAB:  PUSH    AF              ; Save token
1633   2AE1 CD D0 33            CALL    FNDNUM          ; Evaluate expression
1634   2AE4 CD 7B 26            CALL    CHKSYN          ; Make sure ")" follows
1635   2AE7 29                  .BYTE   ")"
1636   2AE8 2B                  DEC     HL              ; Back space on to ")"
1637   2AE9 F1                  POP     AF              ; Restore token
1638   2AEA D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1639   2AEC E5                  PUSH    HL              ; Save code string address
1640   2AED CA F3 2A            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1641   2AF0 3A 3B 41            LD      A,(CURPOS)      ; Get current position
1642   2AF3 2F          DOSPC:  CPL                     ; Number of spaces to print to
1643   2AF4 83                  ADD     A,E             ; Total number to print
1644   2AF5 D2 03 2B            JP      NC,NEXITM       ; TAB < Current POS(X)
1645   2AF8 3C          ASPCS:  INC     A               ; Output A spaces
1646   2AF9 47                  LD      B,A             ; Save number to print
1647   2AFA 3E 20               LD      A,' '           ; Space
1648   2AFC CD 86 26    SPCLP:  CALL    OUTC            ; Output character in A
1649   2AFF 05                  DEC     B               ; Count them
1650   2B00 C2 FC 2A            JP      NZ,SPCLP        ; Repeat if more
1651   2B03 E1          NEXITM: POP     HL              ; Restore code string address
1652   2B04 CD 05 28            CALL    GETCHR          ; Get next character
1653   2B07 C3 52 2A            JP      PRNTLP          ; More to print
1654   2B0A             
1655   2B0A 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1655   2B10 66726F6D2073746172740D0A00
1656   2B1D             
1657   2B1D 3A 5D 41    BADINP: LD      A,(READFG)      ; READ or INPUT?
1658   2B20 B7                  OR      A
1659   2B21 C2 A7 23            JP      NZ,DATSNR       ; READ - ?SN Error
1660   2B24 C1                  POP     BC              ; Throw away code string addr
1661   2B25 21 0A 2B            LD      HL,REDO         ; "Redo from start" message
1662   2B28 CD 4B 31            CALL    PRS             ; Output string
1663   2B2B C3 F8 24            JP      DOAGN           ; Do last INPUT again
1664   2B2E             
1665   2B2E CD B6 30    INPUT:  CALL    IDTEST          ; Test for illegal direct
1666   2B31 7E                  LD      A,(HL)          ; Get character after "INPUT"
1667   2B32 FE 22               CP      '"'             ; Is there a prompt string?
1668   2B34 3E 00               LD      A,0             ; Clear A and leave flags
1669   2B36 32 D5 40            LD      (CTLOFG),A      ; Enable output
1670   2B39 C2 48 2B            JP      NZ,NOPMPT       ; No prompt - get input
1671   2B3C CD 0A 31            CALL    QTSTR           ; Get string terminated by '"'
1672   2B3F CD 7B 26            CALL    CHKSYN          ; Check for ';' after prompt
1673   2B42 3B                  .BYTE   ';'
1674   2B43 E5                  PUSH    HL              ; Save code string address
1675   2B44 CD 4E 31            CALL    PRS1            ; Output prompt string
1676   2B47 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1677   2B48 E5          NOPMPT: PUSH    HL              ; Save code string address
1678   2B49 CD FC 24            CALL    PROMPT          ; Get input with "? " prompt
1679   2B4C C1                  POP     BC              ; Restore code string address
1680   2B4D DA 54 28            JP      C,INPBRK        ; Break pressed - Exit
1681   2B50 23                  INC     HL              ; Next byte
1682   2B51 7E                  LD      A,(HL)          ; Get it
1683   2B52 B7                  OR      A               ; End of line?
1684   2B53 2B                  DEC     HL              ; Back again
1685   2B54 C5                  PUSH    BC              ; Re-save code string address
1686   2B55 CA 9B 29            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1687   2B58 36 2C               LD      (HL),','        ; Store comma as separator
1688   2B5A C3 62 2B            JP      NXTITM          ; Get next item
1689   2B5D             
1690   2B5D E5          READ:   PUSH    HL              ; Save code string address
1691   2B5E 2A 6C 41            LD      HL,(NXTDAT)     ; Next DATA statement
1692   2B61 F6                  .BYTE   0F6H            ; Flag "READ"
1693   2B62 AF          NXTITM: XOR     A               ; Flag "INPUT"
1694   2B63 32 5D 41            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1695   2B66 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1696   2B67 C3 6E 2B            JP      GTVLUS          ; Get values
1697   2B6A             
1698   2B6A CD 7B 26    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1699   2B6D 2C                  .BYTE      ','
1700   2B6E CD 68 2E    GTVLUS: CALL    GETVAR          ; Get variable name
1701   2B71 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1702   2B72 D5                  PUSH    DE              ; Save variable address
1703   2B73 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1704   2B74 FE 2C               CP      ','             ; Comma?
1705   2B76 CA 96 2B            JP      Z,ANTVLU        ; Yes - Get another value
1706   2B79 3A 5D 41            LD      A,(READFG)      ; Is it READ?
1707   2B7C B7                  OR      A
1708   2B7D C2 03 2C            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1709   2B80 3E 3F               LD      A,'?'           ; More INPUT needed
1710   2B82 CD 86 26            CALL    OUTC            ; Output character
1711   2B85 CD FC 24            CALL    PROMPT          ; Get INPUT with prompt
1712   2B88 D1                  POP     DE              ; Variable address
1713   2B89 C1                  POP     BC              ; Code string address
1714   2B8A DA 54 28            JP      C,INPBRK        ; Break pressed
1715   2B8D 23                  INC     HL              ; Point to next DATA byte
1716   2B8E 7E                  LD      A,(HL)          ; Get byte
1717   2B8F B7                  OR      A               ; Is it zero (No input) ?
1718   2B90 2B                  DEC     HL              ; Back space INPUT pointer
1719   2B91 C5                  PUSH    BC              ; Save code string address
1720   2B92 CA 9B 29            JP      Z,NXTDTA        ; Find end of buffer
1721   2B95 D5                  PUSH    DE              ; Save variable address
1722   2B96 3A 3D 41    ANTVLU: LD      A,(TYPE)        ; Check data type
1723   2B99 B7                  OR      A               ; Is it numeric?
1724   2B9A CA C0 2B            JP      Z,INPBIN        ; Yes - Convert to binary
1725   2B9D CD 05 28            CALL    GETCHR          ; Get next character
1726   2BA0 57                  LD      D,A             ; Save input character
1727   2BA1 47                  LD      B,A             ; Again
1728   2BA2 FE 22               CP      '"'             ; Start of literal sting?
1729   2BA4 CA B4 2B            JP      Z,STRENT        ; Yes - Create string entry
1730   2BA7 3A 5D 41            LD      A,(READFG)      ; "READ" or "INPUT" ?
1731   2BAA B7                  OR      A
1732   2BAB 57                  LD      D,A             ; Save 00 if "INPUT"
1733   2BAC CA B1 2B            JP      Z,ITMSEP        ; "INPUT" - End with 00
1734   2BAF 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1735   2BB1 06 2C       ITMSEP: LD      B,','           ; Item separator
1736   2BB3 2B                  DEC     HL              ; Back space for DTSTR
1737   2BB4 CD 0D 31    STRENT: CALL    DTSTR           ; Get string terminated by D
1738   2BB7 EB                  EX      DE,HL           ; String address to DE
1739   2BB8 21 CB 2B            LD      HL,LTSTND       ; Where to go after LETSTR
1740   2BBB E3                  EX      (SP),HL         ; Save HL , get input pointer
1741   2BBC D5                  PUSH    DE              ; Save address of string
1742   2BBD C3 CE 29            JP      LETSTR          ; Assign string to variable
1743   2BC0             
1744   2BC0 CD 05 28    INPBIN: CALL    GETCHR          ; Get next character
1745   2BC3 CD 5B 37            CALL    ASCTFP          ; Convert ASCII to FP number
1746   2BC6 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1747   2BC7 CD AC 36            CALL    FPTHL           ; Move FPREG to variable
1748   2BCA E1                  POP     HL              ; Restore input pointer
1749   2BCB 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1750   2BCC CD 05 28            CALL    GETCHR          ; Get next character
1751   2BCF CA D7 2B            JP      Z,MORDT         ; End of line - More needed?
1752   2BD2 FE 2C               CP      ','             ; Another value?
1753   2BD4 C2 1D 2B            JP      NZ,BADINP       ; No - Bad input
1754   2BD7 E3          MORDT:  EX      (SP),HL         ; Get code string address
1755   2BD8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1756   2BD9 CD 05 28            CALL    GETCHR          ; Get next character
1757   2BDC C2 6A 2B            JP      NZ,NEDMOR       ; More needed - Get it
1758   2BDF D1                  POP     DE              ; Restore DATA pointer
1759   2BE0 3A 5D 41            LD      A,(READFG)      ; "READ" or "INPUT" ?
1760   2BE3 B7                  OR      A
1761   2BE4 EB                  EX      DE,HL           ; DATA pointer to HL
1762   2BE5 C2 2B 28            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1763   2BE8 D5                  PUSH    DE              ; Save code string address
1764   2BE9 B6                  OR      (HL)            ; More input given?
1765   2BEA 21 F2 2B            LD      HL,EXTIG        ; "?Extra ignored" message
1766   2BED C4 4B 31            CALL    NZ,PRS          ; Output string if extra given
1767   2BF0 E1                  POP     HL              ; Restore code string address
1768   2BF1 C9                  RET
1769   2BF2             
1770   2BF2 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1770   2BF8 2069676E6F7265640D0A00
1771   2C03             
1772   2C03 CD 9C 29    FDTLP:  CALL    DATA            ; Get next statement
1773   2C06 B7                  OR      A               ; End of line?
1774   2C07 C2 1C 2C            JP      NZ,FANDT        ; No - See if DATA statement
1775   2C0A 23                  INC     HL
1776   2C0B 7E                  LD      A,(HL)          ; End of program?
1777   2C0C 23                  INC     HL
1778   2C0D B6                  OR      (HL)            ; 00 00 Ends program
1779   2C0E 1E 06               LD      E,OD            ; ?OD Error
1780   2C10 CA C1 23            JP      Z,ERROR         ; Yes - Out of DATA
1781   2C13 23                  INC     HL
1782   2C14 5E                  LD      E,(HL)          ; LSB of line number
1783   2C15 23                  INC     HL
1784   2C16 56                  LD      D,(HL)          ; MSB of line number
1785   2C17 EB                  EX      DE,HL
1786   2C18 22 59 41            LD      (DATLIN),HL     ; Set line of current DATA item
1787   2C1B EB                  EX      DE,HL
1788   2C1C CD 05 28    FANDT:  CALL    GETCHR          ; Get next character
1789   2C1F FE 83               CP      ZDATA           ; "DATA" token
1790   2C21 C2 03 2C            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1791   2C24 C3 96 2B            JP      ANTVLU          ; Found - Convert input
1792   2C27             
1793   2C27 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1794   2C2A C4 68 2E    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1795   2C2D 22 5E 41            LD      (BRKLIN),HL     ; Save code string address
1796   2C30 CD 56 23            CALL    BAKSTK          ; Look for "FOR" block
1797   2C33 C2 B3 23            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1798   2C36 F9                  LD      SP,HL           ; Clear nested loops
1799   2C37 D5                  PUSH    DE              ; Save index address
1800   2C38 7E                  LD      A,(HL)          ; Get sign of STEP
1801   2C39 23                  INC     HL
1802   2C3A F5                  PUSH    AF              ; Save sign of STEP
1803   2C3B D5                  PUSH    DE              ; Save index address
1804   2C3C CD 92 36            CALL    PHLTFP          ; Move index value to FPREG
1805   2C3F E3                  EX      (SP),HL         ; Save address of TO value
1806   2C40 E5                  PUSH    HL              ; Save address of index
1807   2C41 CD FF 33            CALL    ADDPHL          ; Add STEP to index value
1808   2C44 E1                  POP     HL              ; Restore address of index
1809   2C45 CD AC 36            CALL    FPTHL           ; Move value to index variable
1810   2C48 E1                  POP     HL              ; Restore address of TO value
1811   2C49 CD A3 36            CALL    LOADFP          ; Move TO value to BCDE
1812   2C4C E5                  PUSH    HL              ; Save address of line of FOR
1813   2C4D CD CF 36            CALL    CMPNUM          ; Compare index with TO value
1814   2C50 E1                  POP     HL              ; Restore address of line num
1815   2C51 C1                  POP     BC              ; Address of sign of STEP
1816   2C52 90                  SUB     B               ; Compare with expected sign
1817   2C53 CD A3 36            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1818   2C56 CA 62 2C            JP      Z,KILFOR        ; Loop finished - Terminate it
1819   2C59 EB                  EX      DE,HL           ; Loop statement line number
1820   2C5A 22 EC 40            LD      (LINEAT),HL     ; Set loop line number
1821   2C5D 69                  LD      L,C             ; Set code string to loop
1822   2C5E 60                  LD      H,B
1823   2C5F C3 C1 27            JP      PUTFID          ; Put back "FOR" and continue
1824   2C62             
1825   2C62 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1826   2C63 2A 5E 41            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1827   2C66 7E                  LD      A,(HL)          ; Get next byte in code string
1828   2C67 FE 2C               CP      ','             ; More NEXTs ?
1829   2C69 C2 C5 27            JP      NZ,RUNCNT       ; No - Do next statement
1830   2C6C CD 05 28            CALL    GETCHR          ; Position to index name
1831   2C6F CD 2A 2C            CALL    NEXT1           ; Re-enter NEXT routine
1832   2C72             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1833   2C72             
1834   2C72 CD 84 2C    GETNUM: CALL    EVAL            ; Get a numeric expression
1835   2C75 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1836   2C76 37          TSTSTR: SCF                     ; Set carry (string)
1837   2C77 3A 3D 41    CHKTYP: LD      A,(TYPE)        ; Check types match
1838   2C7A 8F                  ADC     A,A             ; Expected + actual
1839   2C7B B7                  OR      A               ; Clear carry , set parity
1840   2C7C E8                  RET     PE              ; Even parity - Types match
1841   2C7D C3 BF 23            JP      TMERR           ; Different types - Error
1842   2C80             
1843   2C80 CD 7B 26    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1844   2C83 28                  .BYTE   "("
1845   2C84 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1846   2C85 16 00               LD      D,0             ; Precedence value
1847   2C87 D5          EVAL1:  PUSH    DE              ; Save precedence
1848   2C88 0E 01               LD      C,1
1849   2C8A CD 8A 23            CALL    CHKSTK          ; Check for 1 level of stack
1850   2C8D CD FB 2C            CALL    OPRND           ; Get next expression value
1851   2C90 22 60 41    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1852   2C93 2A 60 41    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1853   2C96 C1                  POP     BC              ; Precedence value and operator
1854   2C97 78                  LD      A,B             ; Get precedence value
1855   2C98 FE 78               CP      78H             ; "AND" or "OR" ?
1856   2C9A D4 75 2C            CALL    NC,TSTNUM       ; No - Make sure it's a number
1857   2C9D 7E                  LD      A,(HL)          ; Get next operator / function
1858   2C9E 16 00               LD      D,0             ; Clear Last relation
1859   2CA0 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1860   2CA2 DA BC 2C            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1861   2CA5 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1862   2CA7 D2 BC 2C            JP      NC,FOPRND       ; Function - Call it
1863   2CAA FE 01               CP      ZEQUAL-ZGTR     ; "="
1864   2CAC 17                  RLA                     ; <- Test for legal
1865   2CAD AA                  XOR     D               ; <- combinations of < = >
1866   2CAE BA                  CP      D               ; <- by combining last token
1867   2CAF 57                  LD      D,A             ; <- with current one
1868   2CB0 DA AD 23            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1869   2CB3 22 55 41            LD      (CUROPR),HL     ; Save address of current token
1870   2CB6 CD 05 28            CALL    GETCHR          ; Get next character
1871   2CB9 C3 A0 2C            JP      RLTLP           ; Treat the two as one
1872   2CBC             
1873   2CBC 7A          FOPRND: LD      A,D             ; < = > found ?
1874   2CBD B7                  OR      A
1875   2CBE C2 E3 2D            JP      NZ,TSTRED       ; Yes - Test for reduction
1876   2CC1 7E                  LD      A,(HL)          ; Get operator token
1877   2CC2 22 55 41            LD      (CUROPR),HL     ; Save operator address
1878   2CC5 D6 AC               SUB     ZPLUS           ; Operator or function?
1879   2CC7 D8                  RET     C               ; Neither - Exit
1880   2CC8 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1881   2CCA D0                  RET     NC              ; No - Exit
1882   2CCB 5F                  LD      E,A             ; Coded operator
1883   2CCC 3A 3D 41            LD      A,(TYPE)        ; Get data type
1884   2CCF 3D                  DEC     A               ; FF = numeric , 00 = string
1885   2CD0 B3                  OR      E               ; Combine with coded operator
1886   2CD1 7B                  LD      A,E             ; Get coded operator
1887   2CD2 CA 41 32            JP      Z,CONCAT        ; String concatenation
1888   2CD5 07                  RLCA                    ; Times 2
1889   2CD6 83                  ADD     A,E             ; Times 3
1890   2CD7 5F                  LD      E,A             ; To DE (D is 0)
1891   2CD8 21 9F 22            LD      HL,PRITAB       ; Precedence table
1892   2CDB 19                  ADD     HL,DE           ; To the operator concerned
1893   2CDC 78                  LD      A,B             ; Last operator precedence
1894   2CDD 56                  LD      D,(HL)          ; Get evaluation precedence
1895   2CDE BA                  CP      D               ; Compare with eval precedence
1896   2CDF D0                  RET     NC              ; Exit if higher precedence
1897   2CE0 23                  INC     HL              ; Point to routine address
1898   2CE1 CD 75 2C            CALL    TSTNUM          ; Make sure it's a number
1899   2CE4             
1900   2CE4 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1901   2CE5 01 93 2C            LD      BC,EVAL3        ; Where to go on prec' break
1902   2CE8 C5                  PUSH    BC              ; Save on stack for return
1903   2CE9 43                  LD      B,E             ; Save operator
1904   2CEA 4A                  LD      C,D             ; Save precedence
1905   2CEB CD 85 36            CALL    STAKFP          ; Move value to stack
1906   2CEE 58                  LD      E,B             ; Restore operator
1907   2CEF 51                  LD      D,C             ; Restore precedence
1908   2CF0 4E                  LD      C,(HL)          ; Get LSB of routine address
1909   2CF1 23                  INC     HL
1910   2CF2 46                  LD      B,(HL)          ; Get MSB of routine address
1911   2CF3 23                  INC     HL
1912   2CF4 C5                  PUSH    BC              ; Save routine address
1913   2CF5 2A 55 41            LD      HL,(CUROPR)     ; Address of current operator
1914   2CF8 C3 87 2C            JP      EVAL1           ; Loop until prec' break
1915   2CFB             
1916   2CFB AF          OPRND:  XOR     A               ; Get operand routine
1917   2CFC 32 3D 41            LD      (TYPE),A        ; Set numeric expected
1918   2CFF CD 05 28            CALL    GETCHR          ; Get next character
1919   2D02 1E 24               LD      E,MO            ; ?MO Error
1920   2D04 CA C1 23            JP      Z,ERROR         ; No operand - Error
1921   2D07 DA 5B 37            JP      C,ASCTFP        ; Number - Get value
1922   2D0A CD A3 28            CALL    CHKLTR          ; See if a letter
1923   2D0D D2 62 2D            JP      NC,CONVAR       ; Letter - Find variable
1924   2D10 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1925   2D12 20 12               JR		NZ, NOTAMP
1926   2D14 CD 05 28            CALL    GETCHR          ; Get next character
1927   2D17 FE 48               CP      'H'             ; Hex number indicated? [function added]
1928   2D19 CA 9F 3B            JP      Z,HEXTFP        ; Convert Hex to FPREG
1929   2D1C FE 42               CP      'B'             ; Binary number indicated? [function added]
1930   2D1E CA 0F 3C            JP      Z,BINTFP        ; Convert Bin to FPREG
1931   2D21 1E 02               LD      E,SN            ; If neither then a ?SN Error
1932   2D23 CA C1 23            JP      Z,ERROR         ; 
1933   2D26 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1934   2D28 CA FB 2C            JP      Z,OPRND         ; Yes - Look for operand
1935   2D2B FE 2E               CP      '.'             ; '.' ?
1936   2D2D CA 5B 37            JP      Z,ASCTFP        ; Yes - Create FP number
1937   2D30 FE AD               CP      ZMINUS          ; '-' Token ?
1938   2D32 CA 51 2D            JP      Z,MINUS         ; Yes - Do minus
1939   2D35 FE 22               CP      '"'             ; Literal string ?
1940   2D37 CA 0A 31            JP      Z,QTSTR         ; Get string terminated by '"'
1941   2D3A FE AA               CP      ZNOT            ; "NOT" Token ?
1942   2D3C CA 43 2E            JP      Z,EVNOT         ; Yes - Eval NOT expression
1943   2D3F FE A7               CP      ZFN             ; "FN" Token ?
1944   2D41 CA 6E 30            JP      Z,DOFN          ; Yes - Do FN routine
1945   2D44 D6 B6               SUB     ZSGN            ; Is it a function?
1946   2D46 D2 73 2D            JP      NC,FNOFST       ; Yes - Evaluate function
1947   2D49 CD 80 2C    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1948   2D4C CD 7B 26            CALL    CHKSYN          ; Make sure ")" follows
1949   2D4F 29                  .BYTE   ")"
1950   2D50 C9                  RET
1951   2D51             
1952   2D51 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1953   2D53 CD 87 2C            CALL    EVAL1           ; Evaluate until prec' break
1954   2D56 2A 60 41            LD      HL,(NXTOPR)     ; Get next operator address
1955   2D59 E5                  PUSH    HL              ; Save next operator address
1956   2D5A CD 7D 36            CALL    INVSGN          ; Negate value
1957   2D5D CD 75 2C    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1958   2D60 E1                  POP     HL              ; Restore next operator address
1959   2D61 C9                  RET
1960   2D62             
1961   2D62 CD 68 2E    CONVAR: CALL    GETVAR          ; Get variable address to DE
1962   2D65 E5          FRMEVL: PUSH    HL              ; Save code string address
1963   2D66 EB                  EX      DE,HL           ; Variable address to HL
1964   2D67 22 74 41            LD      (FPREG),HL      ; Save address of variable
1965   2D6A 3A 3D 41            LD      A,(TYPE)        ; Get type
1966   2D6D B7                  OR      A               ; Numeric?
1967   2D6E CC 92 36            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1968   2D71 E1                  POP     HL              ; Restore code string address
1969   2D72 C9                  RET
1970   2D73             
1971   2D73 06 00       FNOFST: LD      B,0             ; Get address of function
1972   2D75 07                  RLCA                    ; Double function offset
1973   2D76 4F                  LD      C,A             ; BC = Offset in function table
1974   2D77 C5                  PUSH    BC              ; Save adjusted token value
1975   2D78 CD 05 28            CALL    GETCHR          ; Get next character
1976   2D7B 79                  LD      A,C             ; Get adjusted token value
1977   2D7C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1978   2D7E DA 9A 2D            JP      C,FNVAL         ; No - Do function
1979   2D81 CD 80 2C            CALL    OPNPAR          ; Evaluate expression  (X,...
1980   2D84 CD 7B 26            CALL    CHKSYN          ; Make sure ',' follows
1981   2D87 2C                  .BYTE      ','
1982   2D88 CD 76 2C            CALL    TSTSTR          ; Make sure it's a string
1983   2D8B EB                  EX      DE,HL           ; Save code string address
1984   2D8C 2A 74 41            LD      HL,(FPREG)      ; Get address of string
1985   2D8F E3                  EX      (SP),HL         ; Save address of string
1986   2D90 E5                  PUSH    HL              ; Save adjusted token value
1987   2D91 EB                  EX      DE,HL           ; Restore code string address
1988   2D92 CD D3 33            CALL    GETINT          ; Get integer 0-255
1989   2D95 EB                  EX      DE,HL           ; Save code string address
1990   2D96 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1991   2D97 C3 A2 2D            JP      GOFUNC          ; Jump to string function
1992   2D9A             
1993   2D9A CD 49 2D    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1994   2D9D E3                  EX      (SP),HL         ; HL = Adjusted token value
1995   2D9E 11 5D 2D            LD      DE,RETNUM       ; Return number from function
1996   2DA1 D5                  PUSH    DE              ; Save on stack
1997   2DA2 01 FE 20    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1998   2DA5 09                  ADD     HL,BC           ; Point to right address
1999   2DA6 4E                  LD      C,(HL)          ; Get LSB of address
2000   2DA7 23                  INC     HL              ;
2001   2DA8 66                  LD      H,(HL)          ; Get MSB of address
2002   2DA9 69                  LD      L,C             ; Address to HL
2003   2DAA E9                  JP      (HL)            ; Jump to function
2004   2DAB             
2005   2DAB 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2006   2DAC FE AD               CP      ZMINUS          ; '-' token ?
2007   2DAE C8                  RET     Z               ; Yes - Return
2008   2DAF FE 2D               CP      '-'             ; '-' ASCII ?
2009   2DB1 C8                  RET     Z               ; Yes - Return
2010   2DB2 14                  INC     D               ; Inc to flag positive exponent
2011   2DB3 FE 2B               CP      '+'             ; '+' ASCII ?
2012   2DB5 C8                  RET     Z               ; Yes - Return
2013   2DB6 FE AC               CP      ZPLUS           ; '+' token ?
2014   2DB8 C8                  RET     Z               ; Yes - Return
2015   2DB9 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2016   2DBA C9                  RET                     ; Return "NZ"
2017   2DBB             
2018   2DBB F6          POR:    .BYTE      0F6H            ; Flag "OR"
2019   2DBC AF          PAND:   XOR     A               ; Flag "AND"
2020   2DBD F5                  PUSH    AF              ; Save "AND" / "OR" flag
2021   2DBE CD 75 2C            CALL    TSTNUM          ; Make sure it's a number
2022   2DC1 CD B7 28            CALL    DEINT           ; Get integer -32768 to 32767
2023   2DC4 F1                  POP     AF              ; Restore "AND" / "OR" flag
2024   2DC5 EB                  EX      DE,HL           ; <- Get last
2025   2DC6 C1                  POP     BC              ; <-  value
2026   2DC7 E3                  EX      (SP),HL         ; <-  from
2027   2DC8 EB                  EX      DE,HL           ; <-  stack
2028   2DC9 CD 95 36            CALL    FPBCDE          ; Move last value to FPREG
2029   2DCC F5                  PUSH    AF              ; Save "AND" / "OR" flag
2030   2DCD CD B7 28            CALL    DEINT           ; Get integer -32768 to 32767
2031   2DD0 F1                  POP     AF              ; Restore "AND" / "OR" flag
2032   2DD1 C1                  POP     BC              ; Get value
2033   2DD2 79                  LD      A,C             ; Get LSB
2034   2DD3 21 2C 30            LD      HL,ACPASS       ; Address of save AC as current
2035   2DD6 C2 DE 2D            JP      NZ,POR1         ; Jump if OR
2036   2DD9 A3                  AND     E               ; "AND" LSBs
2037   2DDA 4F                  LD      C,A             ; Save LSB
2038   2DDB 78                  LD      A,B             ; Get MBS
2039   2DDC A2                  AND     D               ; "AND" MSBs
2040   2DDD E9                  JP      (HL)            ; Save AC as current (ACPASS)
2041   2DDE             
2042   2DDE B3          POR1:   OR      E               ; "OR" LSBs
2043   2DDF 4F                  LD      C,A             ; Save LSB
2044   2DE0 78                  LD      A,B             ; Get MSB
2045   2DE1 B2                  OR      D               ; "OR" MSBs
2046   2DE2 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2047   2DE3             
2048   2DE3 21 F5 2D    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2049   2DE6 3A 3D 41            LD      A,(TYPE)        ; Get data type
2050   2DE9 1F                  RRA                     ; Carry set = string
2051   2DEA 7A                  LD      A,D             ; Get last precedence value
2052   2DEB 17                  RLA                     ; Times 2 plus carry
2053   2DEC 5F                  LD      E,A             ; To E
2054   2DED 16 64               LD      D,64H           ; Relational precedence
2055   2DEF 78                  LD      A,B             ; Get current precedence
2056   2DF0 BA                  CP      D               ; Compare with last
2057   2DF1 D0                  RET     NC              ; Eval if last was rel' or log'
2058   2DF2 C3 E4 2C            JP      STKTHS          ; Stack this one and get next
2059   2DF5             
2060   2DF5 F7 2D       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2061   2DF7 79          CMPLG1: LD      A,C             ; Get data type
2062   2DF8 B7                  OR      A
2063   2DF9 1F                  RRA
2064   2DFA C1                  POP     BC              ; Get last expression to BCDE
2065   2DFB D1                  POP     DE
2066   2DFC F5                  PUSH    AF              ; Save status
2067   2DFD CD 77 2C            CALL    CHKTYP          ; Check that types match
2068   2E00 21 39 2E            LD      HL,CMPRES       ; Result to comparison
2069   2E03 E5                  PUSH    HL              ; Save for RETurn
2070   2E04 CA CF 36            JP      Z,CMPNUM        ; Compare values if numeric
2071   2E07 AF                  XOR     A               ; Compare two strings
2072   2E08 32 3D 41            LD      (TYPE),A        ; Set type to numeric
2073   2E0B D5                  PUSH    DE              ; Save string name
2074   2E0C CD 8E 32            CALL    GSTRCU          ; Get current string
2075   2E0F 7E                  LD      A,(HL)          ; Get length of string
2076   2E10 23                  INC     HL
2077   2E11 23                  INC     HL
2078   2E12 4E                  LD      C,(HL)          ; Get LSB of address
2079   2E13 23                  INC     HL
2080   2E14 46                  LD      B,(HL)          ; Get MSB of address
2081   2E15 D1                  POP     DE              ; Restore string name
2082   2E16 C5                  PUSH    BC              ; Save address of string
2083   2E17 F5                  PUSH    AF              ; Save length of string
2084   2E18 CD 92 32            CALL    GSTRDE          ; Get second string
2085   2E1B CD A3 36            CALL    LOADFP          ; Get address of second string
2086   2E1E F1                  POP     AF              ; Restore length of string 1
2087   2E1F 57                  LD      D,A             ; Length to D
2088   2E20 E1                  POP     HL              ; Restore address of string 1
2089   2E21 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2090   2E22 B2                  OR      D               ; Bytes of string 1 to do
2091   2E23 C8                  RET     Z               ; Exit if all bytes compared
2092   2E24 7A                  LD      A,D             ; Get bytes of string 1 to do
2093   2E25 D6 01               SUB     1
2094   2E27 D8                  RET     C               ; Exit if end of string 1
2095   2E28 AF                  XOR     A
2096   2E29 BB                  CP      E               ; Bytes of string 2 to do
2097   2E2A 3C                  INC     A
2098   2E2B D0                  RET     NC              ; Exit if end of string 2
2099   2E2C 15                  DEC     D               ; Count bytes in string 1
2100   2E2D 1D                  DEC     E               ; Count bytes in string 2
2101   2E2E 0A                  LD      A,(BC)          ; Byte in string 2
2102   2E2F BE                  CP      (HL)            ; Compare to byte in string 1
2103   2E30 23                  INC     HL              ; Move up string 1
2104   2E31 03                  INC     BC              ; Move up string 2
2105   2E32 CA 21 2E            JP      Z,CMPSTR        ; Same - Try next bytes
2106   2E35 3F                  CCF                     ; Flag difference (">" or "<")
2107   2E36 C3 5F 36            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2108   2E39             
2109   2E39 3C          CMPRES: INC     A               ; Increment current value
2110   2E3A 8F                  ADC     A,A             ; Double plus carry
2111   2E3B C1                  POP     BC              ; Get other value
2112   2E3C A0                  AND     B               ; Combine them
2113   2E3D C6 FF               ADD     A,-1            ; Carry set if different
2114   2E3F 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2115   2E40 C3 66 36            JP      FLGREL          ; Set current value & continue
2116   2E43             
2117   2E43 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2118   2E45 CD 87 2C            CALL    EVAL1           ; Eval until precedence break
2119   2E48 CD 75 2C            CALL    TSTNUM          ; Make sure it's a number
2120   2E4B CD B7 28            CALL    DEINT           ; Get integer -32768 - 32767
2121   2E4E 7B                  LD      A,E             ; Get LSB
2122   2E4F 2F                  CPL                     ; Invert LSB
2123   2E50 4F                  LD      C,A             ; Save "NOT" of LSB
2124   2E51 7A                  LD      A,D             ; Get MSB
2125   2E52 2F                  CPL                     ; Invert MSB
2126   2E53 CD 2C 30            CALL    ACPASS          ; Save AC as current
2127   2E56 C1                  POP     BC              ; Clean up stack
2128   2E57 C3 93 2C            JP      EVAL3           ; Continue evaluation
2129   2E5A             
2130   2E5A 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2131   2E5B CD 05 28            CALL    GETCHR          ; Get next character
2132   2E5E C8                  RET     Z               ; End of DIM statement
2133   2E5F CD 7B 26            CALL    CHKSYN          ; Make sure ',' follows
2134   2E62 2C                  .BYTE      ','
2135   2E63 01 5A 2E    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2136   2E66 C5                  PUSH    BC              ; Save on stack
2137   2E67 F6                  .BYTE      0F6H            ; Flag "Create" variable
2138   2E68 AF          GETVAR: XOR     A               ; Find variable address,to DE
2139   2E69 32 3C 41            LD      (LCRFLG),A      ; Set locate / create flag
2140   2E6C 46                  LD      B,(HL)          ; Get First byte of name
2141   2E6D CD A3 28    GTFNAM: CALL    CHKLTR          ; See if a letter
2142   2E70 DA AD 23            JP      C,SNERR         ; ?SN Error if not a letter
2143   2E73 AF                  XOR     A
2144   2E74 4F                  LD      C,A             ; Clear second byte of name
2145   2E75 32 3D 41            LD      (TYPE),A        ; Set type to numeric
2146   2E78 CD 05 28            CALL    GETCHR          ; Get next character
2147   2E7B DA 84 2E            JP      C,SVNAM2        ; Numeric - Save in name
2148   2E7E CD A3 28            CALL    CHKLTR          ; See if a letter
2149   2E81 DA 91 2E            JP      C,CHARTY        ; Not a letter - Check type
2150   2E84 4F          SVNAM2: LD      C,A             ; Save second byte of name
2151   2E85 CD 05 28    ENDNAM: CALL    GETCHR          ; Get next character
2152   2E88 DA 85 2E            JP      C,ENDNAM        ; Numeric - Get another
2153   2E8B CD A3 28            CALL    CHKLTR          ; See if a letter
2154   2E8E D2 85 2E            JP      NC,ENDNAM       ; Letter - Get another
2155   2E91 D6 24       CHARTY: SUB     '$'             ; String variable?
2156   2E93 C2 A0 2E            JP      NZ,NOTSTR       ; No - Numeric variable
2157   2E96 3C                  INC     A               ; A = 1 (string type)
2158   2E97 32 3D 41            LD      (TYPE),A        ; Set type to string
2159   2E9A 0F                  RRCA                    ; A = 80H , Flag for string
2160   2E9B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2161   2E9C 4F                  LD      C,A             ; Resave second byte on name
2162   2E9D CD 05 28            CALL    GETCHR          ; Get next character
2163   2EA0 3A 5B 41    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2164   2EA3 3D                  DEC     A
2165   2EA4 CA 4D 2F            JP      Z,ARLDSV        ; Yes - Get array name
2166   2EA7 F2 B0 2E            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2167   2EAA 7E                  LD      A,(HL)          ; Get byte again
2168   2EAB D6 28               SUB     '('             ; Subscripted variable?
2169   2EAD CA 25 2F            JP      Z,SBSCPT        ; Yes - Sort out subscript
2170   2EB0             
2171   2EB0 AF          NSCFOR: XOR     A               ; Simple variable
2172   2EB1 32 5B 41            LD      (FORFLG),A      ; Clear "FOR" flag
2173   2EB4 E5                  PUSH    HL              ; Save code string address
2174   2EB5 50                  LD      D,B             ; DE = Variable name to find
2175   2EB6 59                  LD      E,C
2176   2EB7 2A 6E 41            LD      HL,(FNRGNM)     ; FN argument name
2177   2EBA CD 75 26            CALL    CPDEHL          ; Is it the FN argument?
2178   2EBD 11 70 41            LD      DE,FNARG        ; Point to argument value
2179   2EC0 CA 95 35            JP      Z,POPHRT        ; Yes - Return FN argument value
2180   2EC3 2A 68 41            LD      HL,(VAREND)     ; End of variables
2181   2EC6 EB                  EX      DE,HL           ; Address of end of search
2182   2EC7 2A 66 41            LD      HL,(PROGND)     ; Start of variables address
2183   2ECA CD 75 26    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2184   2ECD CA E3 2E            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2185   2ED0 79                  LD      A,C             ; Get second byte of name
2186   2ED1 96                  SUB     (HL)            ; Compare with name in list
2187   2ED2 23                  INC     HL              ; Move on to first byte
2188   2ED3 C2 D8 2E            JP      NZ,FNTHR        ; Different - Find another
2189   2ED6 78                  LD      A,B             ; Get first byte of name
2190   2ED7 96                  SUB     (HL)            ; Compare with name in list
2191   2ED8 23          FNTHR:  INC     HL              ; Move on to LSB of value
2192   2ED9 CA 17 2F            JP      Z,RETADR        ; Found - Return address
2193   2EDC 23                  INC     HL              ; <- Skip
2194   2EDD 23                  INC     HL              ; <- over
2195   2EDE 23                  INC     HL              ; <- F.P.
2196   2EDF 23                  INC     HL              ; <- value
2197   2EE0 C3 CA 2E            JP      FNDVAR          ; Keep looking
2198   2EE3             
2199   2EE3 E1          CFEVAL: POP     HL              ; Restore code string address
2200   2EE4 E3                  EX      (SP),HL         ; Get return address
2201   2EE5 D5                  PUSH    DE              ; Save address of variable
2202   2EE6 11 65 2D            LD      DE,FRMEVL       ; Return address in EVAL
2203   2EE9 CD 75 26            CALL    CPDEHL          ; Called from EVAL ?
2204   2EEC D1                  POP     DE              ; Restore address of variable
2205   2EED CA 1A 2F            JP      Z,RETNUL        ; Yes - Return null variable
2206   2EF0 E3                  EX      (SP),HL         ; Put back return
2207   2EF1 E5                  PUSH    HL              ; Save code string address
2208   2EF2 C5                  PUSH    BC              ; Save variable name
2209   2EF3 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2210   2EF6 2A 6A 41            LD      HL,(ARREND)     ; End of arrays
2211   2EF9 E5                  PUSH    HL              ; Save end of arrays
2212   2EFA 09                  ADD     HL,BC           ; Move up 6 bytes
2213   2EFB C1                  POP     BC              ; Source address in BC
2214   2EFC E5                  PUSH    HL              ; Save new end address
2215   2EFD CD 79 23            CALL    MOVUP           ; Move arrays up
2216   2F00 E1                  POP     HL              ; Restore new end address
2217   2F01 22 6A 41            LD      (ARREND),HL     ; Set new end address
2218   2F04 60                  LD      H,B             ; End of variables to HL
2219   2F05 69                  LD      L,C
2220   2F06 22 68 41            LD      (VAREND),HL     ; Set new end address
2221   2F09             
2222   2F09 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2223   2F0A 36 00               LD      (HL),0          ; Zero byte in variable
2224   2F0C CD 75 26            CALL    CPDEHL          ; Done them all?
2225   2F0F C2 09 2F            JP      NZ,ZEROLP       ; No - Keep on going
2226   2F12 D1                  POP     DE              ; Get variable name
2227   2F13 73                  LD      (HL),E          ; Store second character
2228   2F14 23                  INC     HL
2229   2F15 72                  LD      (HL),D          ; Store first character
2230   2F16 23                  INC     HL
2231   2F17 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2232   2F18 E1                  POP     HL              ; Restore code string address
2233   2F19 C9                  RET
2234   2F1A             
2235   2F1A 32 77 41    RETNUL: LD      (FPEXP),A       ; Set result to zero
2236   2F1D 21 49 23            LD      HL,ZERBYT       ; Also set a null string
2237   2F20 22 74 41            LD      (FPREG),HL      ; Save for EVAL
2238   2F23 E1                  POP     HL              ; Restore code string address
2239   2F24 C9                  RET
2240   2F25             
2241   2F25 E5          SBSCPT: PUSH    HL              ; Save code string address
2242   2F26 2A 3C 41            LD      HL,(LCRFLG)     ; Locate/Create and Type
2243   2F29 E3                  EX      (SP),HL         ; Save and get code string
2244   2F2A 57                  LD      D,A             ; Zero number of dimensions
2245   2F2B D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2246   2F2C C5                  PUSH    BC              ; Save array name
2247   2F2D CD AB 28            CALL    FPSINT          ; Get subscript (0-32767)
2248   2F30 C1                  POP     BC              ; Restore array name
2249   2F31 F1                  POP     AF              ; Get number of dimensions
2250   2F32 EB                  EX      DE,HL
2251   2F33 E3                  EX      (SP),HL         ; Save subscript value
2252   2F34 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2253   2F35 EB                  EX      DE,HL
2254   2F36 3C                  INC     A               ; Count dimensions
2255   2F37 57                  LD      D,A             ; Save in D
2256   2F38 7E                  LD      A,(HL)          ; Get next byte in code string
2257   2F39 FE 2C               CP      ','             ; Comma (more to come)?
2258   2F3B CA 2B 2F            JP      Z,SCPTLP        ; Yes - More subscripts
2259   2F3E CD 7B 26            CALL    CHKSYN          ; Make sure ")" follows
2260   2F41 29                  .BYTE      ")"
2261   2F42 22 60 41            LD      (NXTOPR),HL     ; Save code string address
2262   2F45 E1                  POP     HL              ; Get LCRFLG and TYPE
2263   2F46 22 3C 41            LD      (LCRFLG),HL     ; Restore Locate/create & type
2264   2F49 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2265   2F4B D5                  PUSH    DE              ; Save number of dimensions (D)
2266   2F4C 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2267   2F4D             
2268   2F4D E5          ARLDSV: PUSH    HL              ; Save code string address
2269   2F4E F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2270   2F4F 2A 68 41            LD      HL,(VAREND)     ; Start of arrays
2271   2F52 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2272   2F53 19          FNDARY: ADD     HL,DE           ; Move to next array start
2273   2F54 EB                  EX      DE,HL
2274   2F55 2A 6A 41            LD      HL,(ARREND)     ; End of arrays
2275   2F58 EB                  EX      DE,HL           ; Current array pointer
2276   2F59 CD 75 26            CALL    CPDEHL          ; End of arrays found?
2277   2F5C CA 85 2F            JP      Z,CREARY        ; Yes - Create array
2278   2F5F 7E                  LD      A,(HL)          ; Get second byte of name
2279   2F60 B9                  CP      C               ; Compare with name given
2280   2F61 23                  INC     HL              ; Move on
2281   2F62 C2 67 2F            JP      NZ,NXTARY       ; Different - Find next array
2282   2F65 7E                  LD      A,(HL)          ; Get first byte of name
2283   2F66 B8                  CP      B               ; Compare with name given
2284   2F67 23          NXTARY: INC     HL              ; Move on
2285   2F68 5E                  LD      E,(HL)          ; Get LSB of next array address
2286   2F69 23                  INC     HL
2287   2F6A 56                  LD      D,(HL)          ; Get MSB of next array address
2288   2F6B 23                  INC     HL
2289   2F6C C2 53 2F            JP      NZ,FNDARY       ; Not found - Keep looking
2290   2F6F 3A 3C 41            LD      A,(LCRFLG)      ; Found Locate or Create it?
2291   2F72 B7                  OR      A
2292   2F73 C2 B6 23            JP      NZ,DDERR        ; Create - ?DD Error
2293   2F76 F1                  POP     AF              ; Locate - Get number of dim'ns
2294   2F77 44                  LD      B,H             ; BC Points to array dim'ns
2295   2F78 4D                  LD      C,L
2296   2F79 CA 95 35            JP      Z,POPHRT        ; Jump if array load/save
2297   2F7C 96                  SUB     (HL)            ; Same number of dimensions?
2298   2F7D CA E3 2F            JP      Z,FINDEL        ; Yes - Find element
2299   2F80 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2300   2F82 C3 C1 23            JP      ERROR           ; Output error
2301   2F85             
2302   2F85 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2303   2F88 F1                  POP     AF              ; Array to save or 0 dim'ns?
2304   2F89 CA CC 28            JP      Z,FCERR         ; Yes - ?FC Error
2305   2F8C 71                  LD      (HL),C          ; Save second byte of name
2306   2F8D 23                  INC     HL
2307   2F8E 70                  LD      (HL),B          ; Save first byte of name
2308   2F8F 23                  INC     HL
2309   2F90 4F                  LD      C,A             ; Number of dimensions to C
2310   2F91 CD 8A 23            CALL    CHKSTK          ; Check if enough memory
2311   2F94 23                  INC     HL              ; Point to number of dimensions
2312   2F95 23                  INC     HL
2313   2F96 22 55 41            LD      (CUROPR),HL     ; Save address of pointer
2314   2F99 71                  LD      (HL),C          ; Set number of dimensions
2315   2F9A 23                  INC     HL
2316   2F9B 3A 3C 41            LD      A,(LCRFLG)      ; Locate of Create?
2317   2F9E 17                  RLA                     ; Carry set = Create
2318   2F9F 79                  LD      A,C             ; Get number of dimensions
2319   2FA0 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2320   2FA3 D2 A8 2F            JP      NC,DEFSIZ       ; Locate - Set default size
2321   2FA6 C1                  POP     BC              ; Get specified dimension size
2322   2FA7 03                  INC     BC              ; Include zero element
2323   2FA8 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2324   2FA9 23                  INC     HL
2325   2FAA 70                  LD      (HL),B          ; Save MSB of dimension size
2326   2FAB 23                  INC     HL
2327   2FAC F5                  PUSH    AF              ; Save num' of dim'ns an status
2328   2FAD E5                  PUSH    HL              ; Save address of dim'n size
2329   2FAE CD 40 37            CALL    MLDEBC          ; Multiply DE by BC to find
2330   2FB1 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2331   2FB2 E1                  POP     HL              ; Restore address of dimension
2332   2FB3 F1                  POP     AF              ; Restore number of dimensions
2333   2FB4 3D                  DEC     A               ; Count them
2334   2FB5 C2 A0 2F            JP      NZ,CRARLP       ; Do next dimension if more
2335   2FB8 F5                  PUSH    AF              ; Save locate/create flag
2336   2FB9 42                  LD      B,D             ; MSB of memory needed
2337   2FBA 4B                  LD      C,E             ; LSB of memory needed
2338   2FBB EB                  EX      DE,HL
2339   2FBC 19                  ADD     HL,DE           ; Add bytes to array start
2340   2FBD DA A2 23            JP      C,OMERR         ; Too big - Error
2341   2FC0 CD 93 23            CALL    ENFMEM          ; See if enough memory
2342   2FC3 22 6A 41            LD      (ARREND),HL     ; Save new end of array
2343   2FC6             
2344   2FC6 2B          ZERARY: DEC     HL              ; Back through array data
2345   2FC7 36 00               LD      (HL),0          ; Set array element to zero
2346   2FC9 CD 75 26            CALL    CPDEHL          ; All elements zeroed?
2347   2FCC C2 C6 2F            JP      NZ,ZERARY       ; No - Keep on going
2348   2FCF 03                  INC     BC              ; Number of bytes + 1
2349   2FD0 57                  LD      D,A             ; A=0
2350   2FD1 2A 55 41            LD      HL,(CUROPR)     ; Get address of array
2351   2FD4 5E                  LD      E,(HL)          ; Number of dimensions
2352   2FD5 EB                  EX      DE,HL           ; To HL
2353   2FD6 29                  ADD     HL,HL           ; Two bytes per dimension size
2354   2FD7 09                  ADD     HL,BC           ; Add number of bytes
2355   2FD8 EB                  EX      DE,HL           ; Bytes needed to DE
2356   2FD9 2B                  DEC     HL
2357   2FDA 2B                  DEC     HL
2358   2FDB 73                  LD      (HL),E          ; Save LSB of bytes needed
2359   2FDC 23                  INC     HL
2360   2FDD 72                  LD      (HL),D          ; Save MSB of bytes needed
2361   2FDE 23                  INC     HL
2362   2FDF F1                  POP     AF              ; Locate / Create?
2363   2FE0 DA 07 30            JP      C,ENDDIM        ; A is 0 , End if create
2364   2FE3 47          FINDEL: LD      B,A             ; Find array element
2365   2FE4 4F                  LD      C,A
2366   2FE5 7E                  LD      A,(HL)          ; Number of dimensions
2367   2FE6 23                  INC     HL
2368   2FE7 16                  .BYTE      16H             ; Skip "POP HL"
2369   2FE8 E1          FNDELP: POP     HL              ; Address of next dim' size
2370   2FE9 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2371   2FEA 23                  INC     HL
2372   2FEB 56                  LD      D,(HL)          ; Get MSB of dim'n size
2373   2FEC 23                  INC     HL
2374   2FED E3                  EX      (SP),HL         ; Save address - Get index
2375   2FEE F5                  PUSH    AF              ; Save number of dim'ns
2376   2FEF CD 75 26            CALL    CPDEHL          ; Dimension too large?
2377   2FF2 D2 80 2F            JP      NC,BSERR        ; Yes - ?BS Error
2378   2FF5 E5                  PUSH    HL              ; Save index
2379   2FF6 CD 40 37            CALL    MLDEBC          ; Multiply previous by size
2380   2FF9 D1                  POP     DE              ; Index supplied to DE
2381   2FFA 19                  ADD     HL,DE           ; Add index to pointer
2382   2FFB F1                  POP     AF              ; Number of dimensions
2383   2FFC 3D                  DEC     A               ; Count them
2384   2FFD 44                  LD      B,H             ; MSB of pointer
2385   2FFE 4D                  LD      C,L             ; LSB of pointer
2386   2FFF C2 E8 2F            JP      NZ,FNDELP       ; More - Keep going
2387   3002 29                  ADD     HL,HL           ; 4 Bytes per element
2388   3003 29                  ADD     HL,HL
2389   3004 C1                  POP     BC              ; Start of array
2390   3005 09                  ADD     HL,BC           ; Point to element
2391   3006 EB                  EX      DE,HL           ; Address of element to DE
2392   3007 2A 60 41    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2393   300A C9                  RET
2394   300B             
2395   300B 2A 6A 41    FRE:    LD      HL,(ARREND)     ; Start of free memory
2396   300E EB                  EX      DE,HL           ; To DE
2397   300F 21 00 00            LD      HL,0            ; End of free memory
2398   3012 39                  ADD     HL,SP           ; Current stack value
2399   3013 3A 3D 41            LD      A,(TYPE)        ; Dummy argument type
2400   3016 B7                  OR      A
2401   3017 CA 27 30            JP      Z,FRENUM        ; Numeric - Free variable space
2402   301A CD 8E 32            CALL    GSTRCU          ; Current string to pool
2403   301D CD 8E 31            CALL    GARBGE          ; Garbage collection
2404   3020 2A EA 40            LD      HL,(STRSPC)     ; Bottom of string space in use
2405   3023 EB                  EX      DE,HL           ; To DE
2406   3024 2A 53 41            LD      HL,(STRBOT)     ; Bottom of string space
2407   3027 7D          FRENUM: LD      A,L             ; Get LSB of end
2408   3028 93                  SUB     E               ; Subtract LSB of beginning
2409   3029 4F                  LD      C,A             ; Save difference if C
2410   302A 7C                  LD      A,H             ; Get MSB of end
2411   302B 9A                  SBC     A,D             ; Subtract MSB of beginning
2412   302C 41          ACPASS: LD      B,C             ; Return integer AC
2413   302D 50          ABPASS: LD      D,B             ; Return integer AB
2414   302E 1E 00               LD      E,0
2415   3030 21 3D 41            LD      HL,TYPE         ; Point to type
2416   3033 73                  LD      (HL),E          ; Set type to numeric
2417   3034 06 90               LD      B,80H+16        ; 16 bit integer
2418   3036 C3 6B 36            JP      RETINT          ; Return the integr
2419   3039             
2420   3039 3A 3B 41    POS:    LD      A,(CURPOS)      ; Get cursor position
2421   303C 47          PASSA:  LD      B,A             ; Put A into AB
2422   303D AF                  XOR     A               ; Zero A
2423   303E C3 2D 30            JP      ABPASS          ; Return integer AB
2424   3041             
2425   3041 CD C4 30    DEF:    CALL    CHEKFN          ; Get "FN" and name
2426   3044 CD B6 30            CALL    IDTEST          ; Test for illegal direct
2427   3047 01 9C 29            LD      BC,DATA         ; To get next statement
2428   304A C5                  PUSH    BC              ; Save address for RETurn
2429   304B D5                  PUSH    DE              ; Save address of function ptr
2430   304C CD 7B 26            CALL    CHKSYN          ; Make sure "(" follows
2431   304F 28                  .BYTE      "("
2432   3050 CD 68 2E            CALL    GETVAR          ; Get argument variable name
2433   3053 E5                  PUSH    HL              ; Save code string address
2434   3054 EB                  EX      DE,HL           ; Argument address to HL
2435   3055 2B                  DEC     HL
2436   3056 56                  LD      D,(HL)          ; Get first byte of arg name
2437   3057 2B                  DEC     HL
2438   3058 5E                  LD      E,(HL)          ; Get second byte of arg name
2439   3059 E1                  POP     HL              ; Restore code string address
2440   305A CD 75 2C            CALL    TSTNUM          ; Make sure numeric argument
2441   305D CD 7B 26            CALL    CHKSYN          ; Make sure ")" follows
2442   3060 29                  .BYTE      ")"
2443   3061 CD 7B 26            CALL    CHKSYN          ; Make sure "=" follows
2444   3064 B4                  .BYTE      ZEQUAL          ; "=" token
2445   3065 44                  LD      B,H             ; Code string address to BC
2446   3066 4D                  LD      C,L
2447   3067 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2448   3068 71                  LD      (HL),C          ; Save LSB of FN code string
2449   3069 23                  INC     HL
2450   306A 70                  LD      (HL),B          ; Save MSB of FN code string
2451   306B C3 03 31            JP      SVSTAD          ; Save address and do function
2452   306E             
2453   306E CD C4 30    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2454   3071 D5                  PUSH    DE              ; Save function pointer address
2455   3072 CD 49 2D            CALL    EVLPAR          ; Evaluate expression in "()"
2456   3075 CD 75 2C            CALL    TSTNUM          ; Make sure numeric result
2457   3078 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2458   3079 5E                  LD      E,(HL)          ; Get LSB of FN code string
2459   307A 23                  INC     HL
2460   307B 56                  LD      D,(HL)          ; Get MSB of FN code string
2461   307C 23                  INC     HL
2462   307D 7A                  LD      A,D             ; And function DEFined?
2463   307E B3                  OR      E
2464   307F CA B9 23            JP      Z,UFERR         ; No - ?UF Error
2465   3082 7E                  LD      A,(HL)          ; Get LSB of argument address
2466   3083 23                  INC     HL
2467   3084 66                  LD      H,(HL)          ; Get MSB of argument address
2468   3085 6F                  LD      L,A             ; HL = Arg variable address
2469   3086 E5                  PUSH    HL              ; Save it
2470   3087 2A 6E 41            LD      HL,(FNRGNM)     ; Get old argument name
2471   308A E3                  EX      (SP),HL ;       ; Save old , Get new
2472   308B 22 6E 41            LD      (FNRGNM),HL     ; Set new argument name
2473   308E 2A 72 41            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2474   3091 E5                  PUSH    HL              ; Save it
2475   3092 2A 70 41            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2476   3095 E5                  PUSH    HL              ; Save it
2477   3096 21 70 41            LD      HL,FNARG        ; HL = Value of argument
2478   3099 D5                  PUSH    DE              ; Save FN code string address
2479   309A CD AC 36            CALL    FPTHL           ; Move FPREG to argument
2480   309D E1                  POP     HL              ; Get FN code string address
2481   309E CD 72 2C            CALL    GETNUM          ; Get value from function
2482   30A1 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2483   30A2 CD 05 28            CALL    GETCHR          ; Get next character
2484   30A5 C2 AD 23            JP      NZ,SNERR        ; Bad character in FN - Error
2485   30A8 E1                  POP     HL              ; Get MSB,EXP of old arg
2486   30A9 22 70 41            LD      (FNARG),HL      ; Restore it
2487   30AC E1                  POP     HL              ; Get LSB,NLSB of old arg
2488   30AD 22 72 41            LD      (FNARG+2),HL    ; Restore it
2489   30B0 E1                  POP     HL              ; Get name of old arg
2490   30B1 22 6E 41            LD      (FNRGNM),HL     ; Restore it
2491   30B4 E1                  POP     HL              ; Restore code string address
2492   30B5 C9                  RET
2493   30B6             
2494   30B6 E5          IDTEST: PUSH    HL              ; Save code string address
2495   30B7 2A EC 40            LD      HL,(LINEAT)     ; Get current line number
2496   30BA 23                  INC     HL              ; -1 means direct statement
2497   30BB 7C                  LD      A,H
2498   30BC B5                  OR      L
2499   30BD E1                  POP     HL              ; Restore code string address
2500   30BE C0                  RET     NZ              ; Return if in program
2501   30BF 1E 16               LD      E,ID            ; ?ID Error
2502   30C1 C3 C1 23            JP      ERROR
2503   30C4             
2504   30C4 CD 7B 26    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2505   30C7 A7                  .BYTE      ZFN             ; "FN" token
2506   30C8 3E 80               LD      A,80H
2507   30CA 32 5B 41            LD      (FORFLG),A      ; Flag FN name to find
2508   30CD B6                  OR      (HL)            ; FN name has bit 7 set
2509   30CE 47                  LD      B,A             ; in first byte of name
2510   30CF CD 6D 2E            CALL    GTFNAM          ; Get FN name
2511   30D2 C3 75 2C            JP      TSTNUM          ; Make sure numeric function
2512   30D5             
2513   30D5 CD 75 2C    STR:    CALL    TSTNUM          ; Make sure it's a number
2514   30D8 CD F9 37            CALL    NUMASC          ; Turn number into text
2515   30DB CD 09 31    STR1:   CALL    CRTST           ; Create string entry for it
2516   30DE CD 8E 32            CALL    GSTRCU          ; Current string to pool
2517   30E1 01 E9 32            LD      BC,TOPOOL       ; Save in string pool
2518   30E4 C5                  PUSH    BC              ; Save address on stack
2519   30E5             
2520   30E5 7E          SAVSTR: LD      A,(HL)          ; Get string length
2521   30E6 23                  INC     HL
2522   30E7 23                  INC     HL
2523   30E8 E5                  PUSH    HL              ; Save pointer to string
2524   30E9 CD 64 31            CALL    TESTR           ; See if enough string space
2525   30EC E1                  POP     HL              ; Restore pointer to string
2526   30ED 4E                  LD      C,(HL)          ; Get LSB of address
2527   30EE 23                  INC     HL
2528   30EF 46                  LD      B,(HL)          ; Get MSB of address
2529   30F0 CD FD 30            CALL    CRTMST          ; Create string entry
2530   30F3 E5                  PUSH    HL              ; Save pointer to MSB of addr
2531   30F4 6F                  LD      L,A             ; Length of string
2532   30F5 CD 81 32            CALL    TOSTRA          ; Move to string area
2533   30F8 D1                  POP     DE              ; Restore pointer to MSB
2534   30F9 C9                  RET
2535   30FA             
2536   30FA CD 64 31    MKTMST: CALL    TESTR           ; See if enough string space
2537   30FD 21 4F 41    CRTMST: LD      HL,TMPSTR       ; Temporary string
2538   3100 E5                  PUSH    HL              ; Save it
2539   3101 77                  LD      (HL),A          ; Save length of string
2540   3102 23                  INC     HL
2541   3103 23          SVSTAD: INC     HL
2542   3104 73                  LD      (HL),E          ; Save LSB of address
2543   3105 23                  INC     HL
2544   3106 72                  LD      (HL),D          ; Save MSB of address
2545   3107 E1                  POP     HL              ; Restore pointer
2546   3108 C9                  RET
2547   3109             
2548   3109 2B          CRTST:  DEC     HL              ; DEC - INCed after
2549   310A 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2550   310C 50                  LD      D,B             ; Quote to D
2551   310D E5          DTSTR:  PUSH    HL              ; Save start
2552   310E 0E FF               LD      C,-1            ; Set counter to -1
2553   3110 23          QTSTLP: INC     HL              ; Move on
2554   3111 7E                  LD      A,(HL)          ; Get byte
2555   3112 0C                  INC     C               ; Count bytes
2556   3113 B7                  OR      A               ; End of line?
2557   3114 CA 1F 31            JP      Z,CRTSTE        ; Yes - Create string entry
2558   3117 BA                  CP      D               ; Terminator D found?
2559   3118 CA 1F 31            JP      Z,CRTSTE        ; Yes - Create string entry
2560   311B B8                  CP      B               ; Terminator B found?
2561   311C C2 10 31            JP      NZ,QTSTLP       ; No - Keep looking
2562   311F FE 22       CRTSTE: CP      '"'             ; End with '"'?
2563   3121 CC 05 28            CALL    Z,GETCHR        ; Yes - Get next character
2564   3124 E3                  EX      (SP),HL         ; Starting quote
2565   3125 23                  INC     HL              ; First byte of string
2566   3126 EB                  EX      DE,HL           ; To DE
2567   3127 79                  LD      A,C             ; Get length
2568   3128 CD FD 30            CALL    CRTMST          ; Create string entry
2569   312B 11 4F 41    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2570   312E 2A 41 41            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2571   3131 22 74 41            LD      (FPREG),HL      ; Save address of string ptr
2572   3134 3E 01               LD      A,1
2573   3136 32 3D 41            LD      (TYPE),A        ; Set type to string
2574   3139 CD AF 36            CALL    DETHL4          ; Move string to pool
2575   313C CD 75 26            CALL    CPDEHL          ; Out of string pool?
2576   313F 22 41 41            LD      (TMSTPT),HL     ; Save new pointer
2577   3142 E1                  POP     HL              ; Restore code string address
2578   3143 7E                  LD      A,(HL)          ; Get next code byte
2579   3144 C0                  RET     NZ              ; Return if pool OK
2580   3145 1E 1E               LD      E,ST            ; ?ST Error
2581   3147 C3 C1 23            JP      ERROR           ; String pool overflow
2582   314A             
2583   314A 23          PRNUMS: INC     HL              ; Skip leading space
2584   314B CD 09 31    PRS:    CALL    CRTST           ; Create string entry for it
2585   314E CD 8E 32    PRS1:   CALL    GSTRCU          ; Current string to pool
2586   3151 CD A3 36            CALL    LOADFP          ; Move string block to BCDE
2587   3154 1C                  INC     E               ; Length + 1
2588   3155 1D          PRSLP:  DEC     E               ; Count characters
2589   3156 C8                  RET     Z               ; End of string
2590   3157 0A                  LD      A,(BC)          ; Get byte to output
2591   3158 CD 86 26            CALL    OUTC            ; Output character in A
2592   315B FE 0D               CP      CR              ; Return?
2593   315D CC B7 2A            CALL    Z,DONULL        ; Yes - Do nulls
2594   3160 03                  INC     BC              ; Next byte in string
2595   3161 C3 55 31            JP      PRSLP           ; More characters to output
2596   3164             
2597   3164 B7          TESTR:  OR      A               ; Test if enough room
2598   3165 0E                  .BYTE      0EH             ; No garbage collection done
2599   3166 F1          GRBDON: POP     AF              ; Garbage collection done
2600   3167 F5                  PUSH    AF              ; Save status
2601   3168 2A EA 40            LD      HL,(STRSPC)     ; Bottom of string space in use
2602   316B EB                  EX      DE,HL           ; To DE
2603   316C 2A 53 41            LD      HL,(STRBOT)     ; Bottom of string area
2604   316F 2F                  CPL                     ; Negate length (Top down)
2605   3170 4F                  LD      C,A             ; -Length to BC
2606   3171 06 FF               LD      B,-1            ; BC = -ve length of string
2607   3173 09                  ADD     HL,BC           ; Add to bottom of space in use
2608   3174 23                  INC     HL              ; Plus one for 2's complement
2609   3175 CD 75 26            CALL    CPDEHL          ; Below string RAM area?
2610   3178 DA 82 31            JP      C,TESTOS        ; Tidy up if not done else err
2611   317B 22 53 41            LD      (STRBOT),HL     ; Save new bottom of area
2612   317E 23                  INC     HL              ; Point to first byte of string
2613   317F EB                  EX      DE,HL           ; Address to DE
2614   3180 F1          POPAF:  POP     AF              ; Throw away status push
2615   3181 C9                  RET
2616   3182             
2617   3182 F1          TESTOS: POP     AF              ; Garbage collect been done?
2618   3183 1E 1A               LD      E,OS            ; ?OS Error
2619   3185 CA C1 23            JP      Z,ERROR         ; Yes - Not enough string apace
2620   3188 BF                  CP      A               ; Flag garbage collect done
2621   3189 F5                  PUSH    AF              ; Save status
2622   318A 01 66 31            LD      BC,GRBDON       ; Garbage collection done
2623   318D C5                  PUSH    BC              ; Save for RETurn
2624   318E 2A 3F 41    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2625   3191 22 53 41    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2626   3194 21 00 00            LD      HL,0
2627   3197 E5                  PUSH    HL              ; Flag no string found
2628   3198 2A EA 40            LD      HL,(STRSPC)     ; Get bottom of string space
2629   319B E5                  PUSH    HL              ; Save bottom of string space
2630   319C 21 43 41            LD      HL,TMSTPL       ; Temporary string pool
2631   319F EB          GRBLP:  EX      DE,HL
2632   31A0 2A 41 41            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2633   31A3 EB                  EX      DE,HL
2634   31A4 CD 75 26            CALL    CPDEHL          ; Temporary string pool done?
2635   31A7 01 9F 31            LD      BC,GRBLP        ; Loop until string pool done
2636   31AA C2 F3 31            JP      NZ,STPOOL       ; No - See if in string area
2637   31AD 2A 66 41            LD      HL,(PROGND)     ; Start of simple variables
2638   31B0 EB          SMPVAR: EX      DE,HL
2639   31B1 2A 68 41            LD      HL,(VAREND)     ; End of simple variables
2640   31B4 EB                  EX      DE,HL
2641   31B5 CD 75 26            CALL    CPDEHL          ; All simple strings done?
2642   31B8 CA C6 31            JP      Z,ARRLP         ; Yes - Do string arrays
2643   31BB 7E                  LD      A,(HL)          ; Get type of variable
2644   31BC 23                  INC     HL
2645   31BD 23                  INC     HL
2646   31BE B7                  OR      A               ; "S" flag set if string
2647   31BF CD F6 31            CALL    STRADD          ; See if string in string area
2648   31C2 C3 B0 31            JP      SMPVAR          ; Loop until simple ones done
2649   31C5             
2650   31C5 C1          GNXARY: POP     BC              ; Scrap address of this array
2651   31C6 EB          ARRLP:  EX      DE,HL
2652   31C7 2A 6A 41            LD      HL,(ARREND)     ; End of string arrays
2653   31CA EB                  EX      DE,HL
2654   31CB CD 75 26            CALL    CPDEHL          ; All string arrays done?
2655   31CE CA 1C 32            JP      Z,SCNEND        ; Yes - Move string if found
2656   31D1 CD A3 36            CALL    LOADFP          ; Get array name to BCDE
2657   31D4 7B                  LD      A,E             ; Get type of array     
2658   31D5 E5                  PUSH    HL              ; Save address of num of dim'ns
2659   31D6 09                  ADD     HL,BC           ; Start of next array
2660   31D7 B7                  OR      A               ; Test type of array
2661   31D8 F2 C5 31            JP      P,GNXARY        ; Numeric array - Ignore it
2662   31DB 22 55 41            LD      (CUROPR),HL     ; Save address of next array
2663   31DE E1                  POP     HL              ; Get address of num of dim'ns
2664   31DF 4E                  LD      C,(HL)          ; BC = Number of dimensions
2665   31E0 06 00               LD      B,0
2666   31E2 09                  ADD     HL,BC           ; Two bytes per dimension size
2667   31E3 09                  ADD     HL,BC
2668   31E4 23                  INC     HL              ; Plus one for number of dim'ns
2669   31E5 EB          GRBARY: EX      DE,HL
2670   31E6 2A 55 41            LD      HL,(CUROPR)     ; Get address of next array
2671   31E9 EB                  EX      DE,HL
2672   31EA CD 75 26            CALL    CPDEHL          ; Is this array finished?
2673   31ED CA C6 31            JP      Z,ARRLP         ; Yes - Get next one
2674   31F0 01 E5 31            LD      BC,GRBARY       ; Loop until array all done
2675   31F3 C5          STPOOL: PUSH    BC              ; Save return address
2676   31F4 F6 80               OR      80H             ; Flag string type
2677   31F6 7E          STRADD: LD      A,(HL)          ; Get string length
2678   31F7 23                  INC     HL
2679   31F8 23                  INC     HL
2680   31F9 5E                  LD      E,(HL)          ; Get LSB of string address
2681   31FA 23                  INC     HL
2682   31FB 56                  LD      D,(HL)          ; Get MSB of string address
2683   31FC 23                  INC     HL
2684   31FD F0                  RET     P               ; Not a string - Return
2685   31FE B7                  OR      A               ; Set flags on string length
2686   31FF C8                  RET     Z               ; Null string - Return
2687   3200 44                  LD      B,H             ; Save variable pointer
2688   3201 4D                  LD      C,L
2689   3202 2A 53 41            LD      HL,(STRBOT)     ; Bottom of new area
2690   3205 CD 75 26            CALL    CPDEHL          ; String been done?
2691   3208 60                  LD      H,B             ; Restore variable pointer
2692   3209 69                  LD      L,C
2693   320A D8                  RET     C               ; String done - Ignore
2694   320B E1                  POP     HL              ; Return address
2695   320C E3                  EX      (SP),HL         ; Lowest available string area
2696   320D CD 75 26            CALL    CPDEHL          ; String within string area?
2697   3210 E3                  EX      (SP),HL         ; Lowest available string area
2698   3211 E5                  PUSH    HL              ; Re-save return address
2699   3212 60                  LD      H,B             ; Restore variable pointer
2700   3213 69                  LD      L,C
2701   3214 D0                  RET     NC              ; Outside string area - Ignore
2702   3215 C1                  POP     BC              ; Get return , Throw 2 away
2703   3216 F1                  POP     AF              ; 
2704   3217 F1                  POP     AF              ; 
2705   3218 E5                  PUSH    HL              ; Save variable pointer
2706   3219 D5                  PUSH    DE              ; Save address of current
2707   321A C5                  PUSH    BC              ; Put back return address
2708   321B C9                  RET                     ; Go to it
2709   321C             
2710   321C D1          SCNEND: POP     DE              ; Addresses of strings
2711   321D E1                  POP     HL              ; 
2712   321E 7D                  LD      A,L             ; HL = 0 if no more to do
2713   321F B4                  OR      H
2714   3220 C8                  RET     Z               ; No more to do - Return
2715   3221 2B                  DEC     HL
2716   3222 46                  LD      B,(HL)          ; MSB of address of string
2717   3223 2B                  DEC     HL
2718   3224 4E                  LD      C,(HL)          ; LSB of address of string
2719   3225 E5                  PUSH    HL              ; Save variable address
2720   3226 2B                  DEC     HL
2721   3227 2B                  DEC     HL
2722   3228 6E                  LD      L,(HL)          ; HL = Length of string
2723   3229 26 00               LD      H,0
2724   322B 09                  ADD     HL,BC           ; Address of end of string+1
2725   322C 50                  LD      D,B             ; String address to DE
2726   322D 59                  LD      E,C
2727   322E 2B                  DEC     HL              ; Last byte in string
2728   322F 44                  LD      B,H             ; Address to BC
2729   3230 4D                  LD      C,L
2730   3231 2A 53 41            LD      HL,(STRBOT)     ; Current bottom of string area
2731   3234 CD 7C 23            CALL    MOVSTR          ; Move string to new address
2732   3237 E1                  POP     HL              ; Restore variable address
2733   3238 71                  LD      (HL),C          ; Save new LSB of address
2734   3239 23                  INC     HL
2735   323A 70                  LD      (HL),B          ; Save new MSB of address
2736   323B 69                  LD      L,C             ; Next string area+1 to HL
2737   323C 60                  LD      H,B
2738   323D 2B                  DEC     HL              ; Next string area address
2739   323E C3 91 31            JP      GARBLP          ; Look for more strings
2740   3241             
2741   3241 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2742   3242 E5                  PUSH    HL              ; 
2743   3243 2A 74 41            LD      HL,(FPREG)      ; Get first string
2744   3246 E3                  EX      (SP),HL         ; Save first string
2745   3247 CD FB 2C            CALL    OPRND           ; Get second string
2746   324A E3                  EX      (SP),HL         ; Restore first string
2747   324B CD 76 2C            CALL    TSTSTR          ; Make sure it's a string
2748   324E 7E                  LD      A,(HL)          ; Get length of second string
2749   324F E5                  PUSH    HL              ; Save first string
2750   3250 2A 74 41            LD      HL,(FPREG)      ; Get second string
2751   3253 E5                  PUSH    HL              ; Save second string
2752   3254 86                  ADD     A,(HL)          ; Add length of second string
2753   3255 1E 1C               LD      E,LS            ; ?LS Error
2754   3257 DA C1 23            JP      C,ERROR         ; String too long - Error
2755   325A CD FA 30            CALL    MKTMST          ; Make temporary string
2756   325D D1                  POP     DE              ; Get second string to DE
2757   325E CD 92 32            CALL    GSTRDE          ; Move to string pool if needed
2758   3261 E3                  EX      (SP),HL         ; Get first string
2759   3262 CD 91 32            CALL    GSTRHL          ; Move to string pool if needed
2760   3265 E5                  PUSH    HL              ; Save first string
2761   3266 2A 51 41            LD      HL,(TMPSTR+2)   ; Temporary string address
2762   3269 EB                  EX      DE,HL           ; To DE
2763   326A CD 78 32            CALL    SSTSA           ; First string to string area
2764   326D CD 78 32            CALL    SSTSA           ; Second string to string area
2765   3270 21 90 2C            LD      HL,EVAL2        ; Return to evaluation loop
2766   3273 E3                  EX      (SP),HL         ; Save return,get code string
2767   3274 E5                  PUSH    HL              ; Save code string address
2768   3275 C3 2B 31            JP      TSTOPL          ; To temporary string to pool
2769   3278             
2770   3278 E1          SSTSA:  POP     HL              ; Return address
2771   3279 E3                  EX      (SP),HL         ; Get string block,save return
2772   327A 7E                  LD      A,(HL)          ; Get length of string
2773   327B 23                  INC     HL
2774   327C 23                  INC     HL
2775   327D 4E                  LD      C,(HL)          ; Get LSB of string address
2776   327E 23                  INC     HL
2777   327F 46                  LD      B,(HL)          ; Get MSB of string address
2778   3280 6F                  LD      L,A             ; Length to L
2779   3281 2C          TOSTRA: INC     L               ; INC - DECed after
2780   3282 2D          TSALP:  DEC     L               ; Count bytes moved
2781   3283 C8                  RET     Z               ; End of string - Return
2782   3284 0A                  LD      A,(BC)          ; Get source
2783   3285 12                  LD      (DE),A          ; Save destination
2784   3286 03                  INC     BC              ; Next source
2785   3287 13                  INC     DE              ; Next destination
2786   3288 C3 82 32            JP      TSALP           ; Loop until string moved
2787   328B             
2788   328B CD 76 2C    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2789   328E 2A 74 41    GSTRCU: LD      HL,(FPREG)      ; Get current string
2790   3291 EB          GSTRHL: EX      DE,HL           ; Save DE
2791   3292 CD AC 32    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2792   3295 EB                  EX      DE,HL           ; Restore DE
2793   3296 C0                  RET     NZ              ; No - Return
2794   3297 D5                  PUSH    DE              ; Save string
2795   3298 50                  LD      D,B             ; String block address to DE
2796   3299 59                  LD      E,C
2797   329A 1B                  DEC     DE              ; Point to length
2798   329B 4E                  LD      C,(HL)          ; Get string length
2799   329C 2A 53 41            LD      HL,(STRBOT)     ; Current bottom of string area
2800   329F CD 75 26            CALL    CPDEHL          ; Last one in string area?
2801   32A2 C2 AA 32            JP      NZ,POPHL        ; No - Return
2802   32A5 47                  LD      B,A             ; Clear B (A=0)
2803   32A6 09                  ADD     HL,BC           ; Remove string from str' area
2804   32A7 22 53 41            LD      (STRBOT),HL     ; Save new bottom of str' area
2805   32AA E1          POPHL:  POP     HL              ; Restore string
2806   32AB C9                  RET
2807   32AC             
2808   32AC 2A 41 41    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2809   32AF 2B                  DEC     HL              ; Back
2810   32B0 46                  LD      B,(HL)          ; Get MSB of address
2811   32B1 2B                  DEC     HL              ; Back
2812   32B2 4E                  LD      C,(HL)          ; Get LSB of address
2813   32B3 2B                  DEC     HL              ; Back
2814   32B4 2B                  DEC     HL              ; Back
2815   32B5 CD 75 26            CALL    CPDEHL          ; String last in string pool?
2816   32B8 C0                  RET     NZ              ; Yes - Leave it
2817   32B9 22 41 41            LD      (TMSTPT),HL     ; Save new string pool top
2818   32BC C9                  RET
2819   32BD             
2820   32BD 01 3C 30    LEN:    LD      BC,PASSA        ; To return integer A
2821   32C0 C5                  PUSH    BC              ; Save address
2822   32C1 CD 8B 32    GETLEN: CALL    GETSTR          ; Get string and its length
2823   32C4 AF                  XOR     A
2824   32C5 57                  LD      D,A             ; Clear D
2825   32C6 32 3D 41            LD      (TYPE),A        ; Set type to numeric
2826   32C9 7E                  LD      A,(HL)          ; Get length of string
2827   32CA B7                  OR      A               ; Set status flags
2828   32CB C9                  RET
2829   32CC             
2830   32CC 01 3C 30    ASC:    LD      BC,PASSA        ; To return integer A
2831   32CF C5                  PUSH    BC              ; Save address
2832   32D0 CD C1 32    GTFLNM: CALL    GETLEN          ; Get length of string
2833   32D3 CA CC 28            JP      Z,FCERR         ; Null string - Error
2834   32D6 23                  INC     HL
2835   32D7 23                  INC     HL
2836   32D8 5E                  LD      E,(HL)          ; Get LSB of address
2837   32D9 23                  INC     HL
2838   32DA 56                  LD      D,(HL)          ; Get MSB of address
2839   32DB 1A                  LD      A,(DE)          ; Get first byte of string
2840   32DC C9                  RET
2841   32DD             
2842   32DD 3E 01       CHR:    LD      A,1             ; One character string
2843   32DF CD FA 30            CALL    MKTMST          ; Make a temporary string
2844   32E2 CD D6 33            CALL    MAKINT          ; Make it integer A
2845   32E5 2A 51 41            LD      HL,(TMPSTR+2)   ; Get address of string
2846   32E8 73                  LD      (HL),E          ; Save character
2847   32E9 C1          TOPOOL: POP     BC              ; Clean up stack
2848   32EA C3 2B 31            JP      TSTOPL          ; Temporary string to pool
2849   32ED             
2850   32ED CD 86 33    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2851   32F0 AF                  XOR     A               ; Start at first byte in string
2852   32F1 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2853   32F2 4F                  LD      C,A             ; Starting position in string
2854   32F3 E5          MID1:   PUSH    HL              ; Save string block address
2855   32F4 7E                  LD      A,(HL)          ; Get length of string
2856   32F5 B8                  CP      B               ; Compare with number given
2857   32F6 DA FB 32            JP      C,ALLFOL        ; All following bytes required
2858   32F9 78                  LD      A,B             ; Get new length
2859   32FA 11                  .BYTE      11H             ; Skip "LD C,0"
2860   32FB 0E 00       ALLFOL: LD      C,0             ; First byte of string
2861   32FD C5                  PUSH    BC              ; Save position in string
2862   32FE CD 64 31            CALL    TESTR           ; See if enough string space
2863   3301 C1                  POP     BC              ; Get position in string
2864   3302 E1                  POP     HL              ; Restore string block address
2865   3303 E5                  PUSH    HL              ; And re-save it
2866   3304 23                  INC     HL
2867   3305 23                  INC     HL
2868   3306 46                  LD      B,(HL)          ; Get LSB of address
2869   3307 23                  INC     HL
2870   3308 66                  LD      H,(HL)          ; Get MSB of address
2871   3309 68                  LD      L,B             ; HL = address of string
2872   330A 06 00               LD      B,0             ; BC = starting address
2873   330C 09                  ADD     HL,BC           ; Point to that byte
2874   330D 44                  LD      B,H             ; BC = source string
2875   330E 4D                  LD      C,L
2876   330F CD FD 30            CALL    CRTMST          ; Create a string entry
2877   3312 6F                  LD      L,A             ; Length of new string
2878   3313 CD 81 32            CALL    TOSTRA          ; Move string to string area
2879   3316 D1                  POP     DE              ; Clear stack
2880   3317 CD 92 32            CALL    GSTRDE          ; Move to string pool if needed
2881   331A C3 2B 31            JP      TSTOPL          ; Temporary string to pool
2882   331D             
2883   331D CD 86 33    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2884   3320 D1                  POP     DE              ; Get string length
2885   3321 D5                  PUSH    DE              ; And re-save
2886   3322 1A                  LD      A,(DE)          ; Get length
2887   3323 90                  SUB     B               ; Move back N bytes
2888   3324 C3 F1 32            JP      RIGHT1          ; Go and get sub-string
2889   3327             
2890   3327 EB          MID:    EX      DE,HL           ; Get code string address
2891   3328 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2892   3329 CD 8B 33            CALL    MIDNUM          ; Get number supplied
2893   332C 04                  INC     B               ; Is it character zero?
2894   332D 05                  DEC     B
2895   332E CA CC 28            JP      Z,FCERR         ; Yes - Error
2896   3331 C5                  PUSH    BC              ; Save starting position
2897   3332 1E FF               LD      E,255           ; All of string
2898   3334 FE 29               CP      ')'             ; Any length given?
2899   3336 CA 40 33            JP      Z,RSTSTR        ; No - Rest of string
2900   3339 CD 7B 26            CALL    CHKSYN          ; Make sure ',' follows
2901   333C 2C                  .BYTE      ','
2902   333D CD D3 33            CALL    GETINT          ; Get integer 0-255
2903   3340 CD 7B 26    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2904   3343 29                  .BYTE      ")"
2905   3344 F1                  POP     AF              ; Restore starting position
2906   3345 E3                  EX      (SP),HL         ; Get string,8ave code string
2907   3346 01 F3 32            LD      BC,MID1         ; Continuation of MID$ routine
2908   3349 C5                  PUSH    BC              ; Save for return
2909   334A 3D                  DEC     A               ; Starting position-1
2910   334B BE                  CP      (HL)            ; Compare with length
2911   334C 06 00               LD      B,0             ; Zero bytes length
2912   334E D0                  RET     NC              ; Null string if start past end
2913   334F 4F                  LD      C,A             ; Save starting position-1
2914   3350 7E                  LD      A,(HL)          ; Get length of string
2915   3351 91                  SUB     C               ; Subtract start
2916   3352 BB                  CP      E               ; Enough string for it?
2917   3353 47                  LD      B,A             ; Save maximum length available
2918   3354 D8                  RET     C               ; Truncate string if needed
2919   3355 43                  LD      B,E             ; Set specified length
2920   3356 C9                  RET                     ; Go and create string
2921   3357             
2922   3357 CD C1 32    VAL:    CALL    GETLEN          ; Get length of string
2923   335A CA 74 34            JP      Z,RESZER        ; Result zero
2924   335D 5F                  LD      E,A             ; Save length
2925   335E 23                  INC     HL
2926   335F 23                  INC     HL
2927   3360 7E                  LD      A,(HL)          ; Get LSB of address
2928   3361 23                  INC     HL
2929   3362 66                  LD      H,(HL)          ; Get MSB of address
2930   3363 6F                  LD      L,A             ; HL = String address
2931   3364 E5                  PUSH    HL              ; Save string address
2932   3365 19                  ADD     HL,DE
2933   3366 46                  LD      B,(HL)          ; Get end of string+1 byte
2934   3367 72                  LD      (HL),D          ; Zero it to terminate
2935   3368 E3                  EX      (SP),HL         ; Save string end,get start
2936   3369 C5                  PUSH    BC              ; Save end+1 byte
2937   336A 7E                  LD      A,(HL)          ; Get starting byte
2938   336B FE 24           CP	'$'		; Hex number indicated? [function added]
2939   336D C2 75 33        JP	NZ,VAL1
2940   3370 CD 9F 3B        CALL	HEXTFP		; Convert Hex to FPREG
2941   3373 18 0D           JR	VAL3
2942   3375 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2943   3377 C2 7F 33        JP	NZ,VAL2
2944   337A CD 0F 3C        CALL	BINTFP		; Convert Bin to FPREG
2945   337D 18 03           JR	VAL3
2946   337F CD 5B 37    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2947   3382 C1          VAL3:   POP     BC              ; Restore end+1 byte
2948   3383 E1                  POP     HL              ; Restore end+1 address
2949   3384 70                  LD      (HL),B          ; Put back original byte
2950   3385 C9                  RET
2951   3386             
2952   3386 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2953   3387 CD 7B 26            CALL    CHKSYN          ; Make sure ")" follows
2954   338A 29                  .BYTE      ")"
2955   338B C1          MIDNUM: POP     BC              ; Get return address
2956   338C D1                  POP     DE              ; Get number supplied
2957   338D C5                  PUSH    BC              ; Re-save return address
2958   338E 43                  LD      B,E             ; Number to B
2959   338F C9                  RET
2960   3390             
2961   3390 CD D6 33    INP:    CALL    MAKINT          ; Make it integer A
2962   3393 32 CF 40            LD      (INPORT),A      ; Set input port
2963   3396 CD CE 40            CALL    INPSUB          ; Get input from port
2964   3399 C3 3C 30            JP      PASSA           ; Return integer A
2965   339C             
2966   339C CD C0 33    POUT:   CALL    SETIO           ; Set up port number
2967   339F C3 96 40            JP      OUTSUB          ; Output data and return
2968   33A2             
2969   33A2 CD C0 33    WAIT:   CALL    SETIO           ; Set up port number
2970   33A5 F5                  PUSH    AF              ; Save AND mask
2971   33A6 1E 00               LD      E,0             ; Assume zero if none given
2972   33A8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2973   33A9 CD 05 28            CALL    GETCHR          ; Get next character
2974   33AC CA B6 33            JP      Z,NOXOR         ; No XOR byte given
2975   33AF CD 7B 26            CALL    CHKSYN          ; Make sure ',' follows
2976   33B2 2C                  .BYTE      ','
2977   33B3 CD D3 33            CALL    GETINT          ; Get integer 0-255 to XOR with
2978   33B6 C1          NOXOR:  POP     BC              ; Restore AND mask
2979   33B7 CD CE 40    WAITLP: CALL    INPSUB          ; Get input
2980   33BA AB                  XOR     E               ; Flip selected bits
2981   33BB A0                  AND     B               ; Result non-zero?
2982   33BC CA B7 33            JP      Z,WAITLP        ; No = keep waiting
2983   33BF C9                  RET
2984   33C0             
2985   33C0 CD D3 33    SETIO:  CALL    GETINT          ; Get integer 0-255
2986   33C3 32 CF 40            LD      (INPORT),A      ; Set input port
2987   33C6 32 97 40            LD      (OTPORT),A      ; Set output port
2988   33C9 CD 7B 26            CALL    CHKSYN          ; Make sure ',' follows
2989   33CC 2C                  .BYTE      ','
2990   33CD C3 D3 33            JP      GETINT          ; Get integer 0-255 and return
2991   33D0             
2992   33D0 CD 05 28    FNDNUM: CALL    GETCHR          ; Get next character
2993   33D3 CD 72 2C    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2994   33D6 CD B1 28    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2995   33D9 7A                  LD      A,D             ; Get MSB of number
2996   33DA B7                  OR      A               ; Zero?
2997   33DB C2 CC 28            JP      NZ,FCERR        ; No - Error
2998   33DE 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2999   33DF CD 05 28            CALL    GETCHR          ; Get next character
3000   33E2 7B                  LD      A,E             ; Get number to A
3001   33E3 C9                  RET
3002   33E4             
3003   33E4 CD B7 28    PEEK:   CALL    DEINT           ; Get memory address
3004   33E7 1A                  LD      A,(DE)          ; Get byte in memory
3005   33E8 C3 3C 30            JP      PASSA           ; Return integer A
3006   33EB             
3007   33EB CD 72 2C    POKE:   CALL    GETNUM          ; Get memory address
3008   33EE CD B7 28            CALL    DEINT           ; Get integer -32768 to 3276
3009   33F1 D5                  PUSH    DE              ; Save memory address
3010   33F2 CD 7B 26            CALL    CHKSYN          ; Make sure ',' follows
3011   33F5 2C                  .BYTE      ','
3012   33F6 CD D3 33            CALL    GETINT          ; Get integer 0-255
3013   33F9 D1                  POP     DE              ; Restore memory address
3014   33FA 12                  LD      (DE),A          ; Load it into memory
3015   33FB C9                  RET
3016   33FC             
3017   33FC 21 D2 38    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3018   33FF CD A3 36    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3019   3402 C3 0E 34            JP      FPADD           ; Add BCDE to FPREG
3020   3405             
3021   3405 CD A3 36    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3022   3408 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3023   3409 C1          PSUB:   POP     BC              ; Get FP number from stack
3024   340A D1                  POP     DE
3025   340B CD 7D 36    SUBCDE: CALL    INVSGN          ; Negate FPREG
3026   340E 78          FPADD:  LD      A,B             ; Get FP exponent
3027   340F B7                  OR      A               ; Is number zero?
3028   3410 C8                  RET     Z               ; Yes - Nothing to add
3029   3411 3A 77 41            LD      A,(FPEXP)       ; Get FPREG exponent
3030   3414 B7                  OR      A               ; Is this number zero?
3031   3415 CA 95 36            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3032   3418 90                  SUB     B               ; BCDE number larger?
3033   3419 D2 28 34            JP      NC,NOSWAP       ; No - Don't swap them
3034   341C 2F                  CPL                     ; Two's complement
3035   341D 3C                  INC     A               ;  FP exponent
3036   341E EB                  EX      DE,HL
3037   341F CD 85 36            CALL    STAKFP          ; Put FPREG on stack
3038   3422 EB                  EX      DE,HL
3039   3423 CD 95 36            CALL    FPBCDE          ; Move BCDE to FPREG
3040   3426 C1                  POP     BC              ; Restore number from stack
3041   3427 D1                  POP     DE
3042   3428 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3043   342A D0                  RET     NC              ; Yes - First number is result
3044   342B F5                  PUSH    AF              ; Save number of bits to scale
3045   342C CD BA 36            CALL    SIGNS           ; Set MSBs & sign of result
3046   342F 67                  LD      H,A             ; Save sign of result
3047   3430 F1                  POP     AF              ; Restore scaling factor
3048   3431 CD D3 34            CALL    SCALE           ; Scale BCDE to same exponent
3049   3434 B4                  OR      H               ; Result to be positive?
3050   3435 21 74 41            LD      HL,FPREG        ; Point to FPREG
3051   3438 F2 4E 34            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3052   343B CD B3 34            CALL    PLUCDE          ; Add FPREG to CDE
3053   343E D2 94 34            JP      NC,RONDUP       ; No overflow - Round it up
3054   3441 23                  INC     HL              ; Point to exponent
3055   3442 34                  INC     (HL)            ; Increment it
3056   3443 CA BC 23            JP      Z,OVERR         ; Number overflowed - Error
3057   3446 2E 01               LD      L,1             ; 1 bit to shift right
3058   3448 CD E9 34            CALL    SHRT1           ; Shift result right
3059   344B C3 94 34            JP      RONDUP          ; Round it up
3060   344E             
3061   344E AF          MINCDE: XOR     A               ; Clear A and carry
3062   344F 90                  SUB     B               ; Negate exponent
3063   3450 47                  LD      B,A             ; Re-save exponent
3064   3451 7E                  LD      A,(HL)          ; Get LSB of FPREG
3065   3452 9B                  SBC     A, E            ; Subtract LSB of BCDE
3066   3453 5F                  LD      E,A             ; Save LSB of BCDE
3067   3454 23                  INC     HL
3068   3455 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3069   3456 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3070   3457 57                  LD      D,A             ; Save NMSB of BCDE
3071   3458 23                  INC     HL
3072   3459 7E                  LD      A,(HL)          ; Get MSB of FPREG
3073   345A 99                  SBC     A,C             ; Subtract MSB of BCDE
3074   345B 4F                  LD      C,A             ; Save MSB of BCDE
3075   345C DC BF 34    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3076   345F             
3077   345F 68          BNORM:  LD      L,B             ; L = Exponent
3078   3460 63                  LD      H,E             ; H = LSB
3079   3461 AF                  XOR     A
3080   3462 47          BNRMLP: LD      B,A             ; Save bit count
3081   3463 79                  LD      A,C             ; Get MSB
3082   3464 B7                  OR      A               ; Is it zero?
3083   3465 C2 81 34            JP      NZ,PNORM        ; No - Do it bit at a time
3084   3468 4A                  LD      C,D             ; MSB = NMSB
3085   3469 54                  LD      D,H             ; NMSB= LSB
3086   346A 65                  LD      H,L             ; LSB = VLSB
3087   346B 6F                  LD      L,A             ; VLSB= 0
3088   346C 78                  LD      A,B             ; Get exponent
3089   346D D6 08               SUB     8               ; Count 8 bits
3090   346F FE E0               CP      -24-8           ; Was number zero?
3091   3471 C2 62 34            JP      NZ,BNRMLP       ; No - Keep normalising
3092   3474 AF          RESZER: XOR     A               ; Result is zero
3093   3475 32 77 41    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3094   3478 C9                  RET
3095   3479             
3096   3479 05          NORMAL: DEC     B               ; Count bits
3097   347A 29                  ADD     HL,HL           ; Shift HL left
3098   347B 7A                  LD      A,D             ; Get NMSB
3099   347C 17                  RLA                     ; Shift left with last bit
3100   347D 57                  LD      D,A             ; Save NMSB
3101   347E 79                  LD      A,C             ; Get MSB
3102   347F 8F                  ADC     A,A             ; Shift left with last bit
3103   3480 4F                  LD      C,A             ; Save MSB
3104   3481 F2 79 34    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3105   3484 78                  LD      A,B             ; Number of bits shifted
3106   3485 5C                  LD      E,H             ; Save HL in EB
3107   3486 45                  LD      B,L
3108   3487 B7                  OR      A               ; Any shifting done?
3109   3488 CA 94 34            JP      Z,RONDUP        ; No - Round it up
3110   348B 21 77 41            LD      HL,FPEXP        ; Point to exponent
3111   348E 86                  ADD     A,(HL)          ; Add shifted bits
3112   348F 77                  LD      (HL),A          ; Re-save exponent
3113   3490 D2 74 34            JP      NC,RESZER       ; Underflow - Result is zero
3114   3493 C8                  RET     Z               ; Result is zero
3115   3494 78          RONDUP: LD      A,B             ; Get VLSB of number
3116   3495 21 77 41    RONDB:  LD      HL,FPEXP        ; Point to exponent
3117   3498 B7                  OR      A               ; Any rounding?
3118   3499 FC A6 34            CALL    M,FPROND        ; Yes - Round number up
3119   349C 46                  LD      B,(HL)          ; B = Exponent
3120   349D 23                  INC     HL
3121   349E 7E                  LD      A,(HL)          ; Get sign of result
3122   349F E6 80               AND     10000000B       ; Only bit 7 needed
3123   34A1 A9                  XOR     C               ; Set correct sign
3124   34A2 4F                  LD      C,A             ; Save correct sign in number
3125   34A3 C3 95 36            JP      FPBCDE          ; Move BCDE to FPREG
3126   34A6             
3127   34A6 1C          FPROND: INC     E               ; Round LSB
3128   34A7 C0                  RET     NZ              ; Return if ok
3129   34A8 14                  INC     D               ; Round NMSB
3130   34A9 C0                  RET     NZ              ; Return if ok
3131   34AA 0C                  INC     C               ; Round MSB
3132   34AB C0                  RET     NZ              ; Return if ok
3133   34AC 0E 80               LD      C,80H           ; Set normal value
3134   34AE 34                  INC     (HL)            ; Increment exponent
3135   34AF C0                  RET     NZ              ; Return if ok
3136   34B0 C3 BC 23            JP      OVERR           ; Overflow error
3137   34B3             
3138   34B3 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3139   34B4 83                  ADD     A,E             ; Add LSB of BCDE
3140   34B5 5F                  LD      E,A             ; Save LSB of BCDE
3141   34B6 23                  INC     HL
3142   34B7 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3143   34B8 8A                  ADC     A,D             ; Add NMSB of BCDE
3144   34B9 57                  LD      D,A             ; Save NMSB of BCDE
3145   34BA 23                  INC     HL
3146   34BB 7E                  LD      A,(HL)          ; Get MSB of FPREG
3147   34BC 89                  ADC     A,C             ; Add MSB of BCDE
3148   34BD 4F                  LD      C,A             ; Save MSB of BCDE
3149   34BE C9                  RET
3150   34BF             
3151   34BF 21 78 41    COMPL:  LD      HL,SGNRES       ; Sign of result
3152   34C2 7E                  LD      A,(HL)          ; Get sign of result
3153   34C3 2F                  CPL                     ; Negate it
3154   34C4 77                  LD      (HL),A          ; Put it back
3155   34C5 AF                  XOR     A
3156   34C6 6F                  LD      L,A             ; Set L to zero
3157   34C7 90                  SUB     B               ; Negate exponent,set carry
3158   34C8 47                  LD      B,A             ; Re-save exponent
3159   34C9 7D                  LD      A,L             ; Load zero
3160   34CA 9B                  SBC     A,E             ; Negate LSB
3161   34CB 5F                  LD      E,A             ; Re-save LSB
3162   34CC 7D                  LD      A,L             ; Load zero
3163   34CD 9A                  SBC     A,D             ; Negate NMSB
3164   34CE 57                  LD      D,A             ; Re-save NMSB
3165   34CF 7D                  LD      A,L             ; Load zero
3166   34D0 99                  SBC     A,C             ; Negate MSB
3167   34D1 4F                  LD      C,A             ; Re-save MSB
3168   34D2 C9                  RET
3169   34D3             
3170   34D3 06 00       SCALE:  LD      B,0             ; Clear underflow
3171   34D5 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3172   34D7 DA E2 34            JP      C,SHRITE        ; No - Shift right A bits
3173   34DA 43                  LD      B,E             ; <- Shift
3174   34DB 5A                  LD      E,D             ; <- right
3175   34DC 51                  LD      D,C             ; <- eight
3176   34DD 0E 00               LD      C,0             ; <- bits
3177   34DF C3 D5 34            JP      SCALLP          ; More bits to shift
3178   34E2             
3179   34E2 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3180   34E4 6F                  LD      L,A             ; Save bits to shift
3181   34E5 AF          SHRLP:  XOR     A               ; Flag for all done
3182   34E6 2D                  DEC     L               ; All shifting done?
3183   34E7 C8                  RET     Z               ; Yes - Return
3184   34E8 79                  LD      A,C             ; Get MSB
3185   34E9 1F          SHRT1:  RRA                     ; Shift it right
3186   34EA 4F                  LD      C,A             ; Re-save
3187   34EB 7A                  LD      A,D             ; Get NMSB
3188   34EC 1F                  RRA                     ; Shift right with last bit
3189   34ED 57                  LD      D,A             ; Re-save it
3190   34EE 7B                  LD      A,E             ; Get LSB
3191   34EF 1F                  RRA                     ; Shift right with last bit
3192   34F0 5F                  LD      E,A             ; Re-save it
3193   34F1 78                  LD      A,B             ; Get underflow
3194   34F2 1F                  RRA                     ; Shift right with last bit
3195   34F3 47                  LD      B,A             ; Re-save underflow
3196   34F4 C3 E5 34            JP      SHRLP           ; More bits to do
3197   34F7             
3198   34F7 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3199   34FB             
3200   34FB 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3201   34FC AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3202   3500 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3203   3504 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3204   3508             
3205   3508 CD 54 36    LOG:    CALL    TSTSGN          ; Test sign of value
3206   350B B7                  OR      A
3207   350C EA CC 28            JP      PE,FCERR        ; ?FC Error if <= zero
3208   350F 21 77 41            LD      HL,FPEXP        ; Point to exponent
3209   3512 7E                  LD      A,(HL)          ; Get exponent
3210   3513 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3211   3516 11 F3 04            LD      DE,04F3H
3212   3519 90                  SUB     B               ; Scale value to be < 1
3213   351A F5                  PUSH    AF              ; Save scale factor
3214   351B 70                  LD      (HL),B          ; Save new exponent
3215   351C D5                  PUSH    DE              ; Save SQR(1/2)
3216   351D C5                  PUSH    BC
3217   351E CD 0E 34            CALL    FPADD           ; Add SQR(1/2) to value
3218   3521 C1                  POP     BC              ; Restore SQR(1/2)
3219   3522 D1                  POP     DE
3220   3523 04                  INC     B               ; Make it SQR(2)
3221   3524 CD AA 35            CALL    DVBCDE          ; Divide by SQR(2)
3222   3527 21 F7 34            LD      HL,UNITY        ; Point to 1.
3223   352A CD 05 34            CALL    SUBPHL          ; Subtract FPREG from 1
3224   352D 21 FB 34            LD      HL,LOGTAB       ; Coefficient table
3225   3530 CD 9C 39            CALL    SUMSER          ; Evaluate sum of series
3226   3533 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3227   3536 11 00 00            LD      DE,0000H
3228   3539 CD 0E 34            CALL    FPADD           ; Subtract 0.5 from FPREG
3229   353C F1                  POP     AF              ; Restore scale factor
3230   353D CD CF 37            CALL    RSCALE          ; Re-scale number
3231   3540 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3232   3543 11 18 72            LD      DE,7218H
3233   3546 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3234   3547             
3235   3547 C1          MULT:   POP     BC              ; Get number from stack
3236   3548 D1                  POP     DE
3237   3549 CD 54 36    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3238   354C C8                  RET     Z               ; Return zero if zero
3239   354D 2E 00               LD      L,0             ; Flag add exponents
3240   354F CD 12 36            CALL    ADDEXP          ; Add exponents
3241   3552 79                  LD      A,C             ; Get MSB of multiplier
3242   3553 32 86 41            LD      (MULVAL),A      ; Save MSB of multiplier
3243   3556 EB                  EX      DE,HL
3244   3557 22 87 41            LD      (MULVAL+1),HL   ; Save rest of multiplier
3245   355A 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3246   355D 50                  LD      D,B
3247   355E 58                  LD      E,B
3248   355F 21 5F 34            LD      HL,BNORM        ; Address of normalise
3249   3562 E5                  PUSH    HL              ; Save for return
3250   3563 21 6B 35            LD      HL,MULT8        ; Address of 8 bit multiply
3251   3566 E5                  PUSH    HL              ; Save for NMSB,MSB
3252   3567 E5                  PUSH    HL              ; 
3253   3568 21 74 41            LD      HL,FPREG        ; Point to number
3254   356B 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3255   356C 23                  INC     HL              ; Point to NMSB
3256   356D B7                  OR      A               ; Test LSB
3257   356E CA 97 35            JP      Z,BYTSFT        ; Zero - shift to next byte
3258   3571 E5                  PUSH    HL              ; Save address of number
3259   3572 2E 08               LD      L,8             ; 8 bits to multiply by
3260   3574 1F          MUL8LP: RRA                     ; Shift LSB right
3261   3575 67                  LD      H,A             ; Save LSB
3262   3576 79                  LD      A,C             ; Get MSB
3263   3577 D2 85 35            JP      NC,NOMADD       ; Bit was zero - Don't add
3264   357A E5                  PUSH    HL              ; Save LSB and count
3265   357B 2A 87 41            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3266   357E 19                  ADD     HL,DE           ; Add NMSB and LSB
3267   357F EB                  EX      DE,HL           ; Leave sum in DE
3268   3580 E1                  POP     HL              ; Restore MSB and count
3269   3581 3A 86 41            LD      A,(MULVAL)      ; Get MSB of multiplier
3270   3584 89                  ADC     A,C             ; Add MSB
3271   3585 1F          NOMADD: RRA                     ; Shift MSB right
3272   3586 4F                  LD      C,A             ; Re-save MSB
3273   3587 7A                  LD      A,D             ; Get NMSB
3274   3588 1F                  RRA                     ; Shift NMSB right
3275   3589 57                  LD      D,A             ; Re-save NMSB
3276   358A 7B                  LD      A,E             ; Get LSB
3277   358B 1F                  RRA                     ; Shift LSB right
3278   358C 5F                  LD      E,A             ; Re-save LSB
3279   358D 78                  LD      A,B             ; Get VLSB
3280   358E 1F                  RRA                     ; Shift VLSB right
3281   358F 47                  LD      B,A             ; Re-save VLSB
3282   3590 2D                  DEC     L               ; Count bits multiplied
3283   3591 7C                  LD      A,H             ; Get LSB of multiplier
3284   3592 C2 74 35            JP      NZ,MUL8LP       ; More - Do it
3285   3595 E1          POPHRT: POP     HL              ; Restore address of number
3286   3596 C9                  RET
3287   3597             
3288   3597 43          BYTSFT: LD      B,E             ; Shift partial product left
3289   3598 5A                  LD      E,D
3290   3599 51                  LD      D,C
3291   359A 4F                  LD      C,A
3292   359B C9                  RET
3293   359C             
3294   359C CD 85 36    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3295   359F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3296   35A2 11 00 00            LD      DE,0000H
3297   35A5 CD 95 36            CALL    FPBCDE          ; Move 10 to FPREG
3298   35A8             
3299   35A8 C1          DIV:    POP     BC              ; Get number from stack
3300   35A9 D1                  POP     DE
3301   35AA CD 54 36    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3302   35AD CA B0 23            JP      Z,DZERR         ; Error if division by zero
3303   35B0 2E FF               LD      L,-1            ; Flag subtract exponents
3304   35B2 CD 12 36            CALL    ADDEXP          ; Subtract exponents
3305   35B5 34                  INC     (HL)            ; Add 2 to exponent to adjust
3306   35B6 34                  INC     (HL)
3307   35B7 2B                  DEC     HL              ; Point to MSB
3308   35B8 7E                  LD      A,(HL)          ; Get MSB of dividend
3309   35B9 32 A2 40            LD      (DIV3),A        ; Save for subtraction
3310   35BC 2B                  DEC     HL
3311   35BD 7E                  LD      A,(HL)          ; Get NMSB of dividend
3312   35BE 32 9E 40            LD      (DIV2),A        ; Save for subtraction
3313   35C1 2B                  DEC     HL
3314   35C2 7E                  LD      A,(HL)          ; Get MSB of dividend
3315   35C3 32 9A 40            LD      (DIV1),A        ; Save for subtraction
3316   35C6 41                  LD      B,C             ; Get MSB
3317   35C7 EB                  EX      DE,HL           ; NMSB,LSB to HL
3318   35C8 AF                  XOR     A
3319   35C9 4F                  LD      C,A             ; Clear MSB of quotient
3320   35CA 57                  LD      D,A             ; Clear NMSB of quotient
3321   35CB 5F                  LD      E,A             ; Clear LSB of quotient
3322   35CC 32 A5 40            LD      (DIV4),A        ; Clear overflow count
3323   35CF E5          DIVLP:  PUSH    HL              ; Save divisor
3324   35D0 C5                  PUSH    BC
3325   35D1 7D                  LD      A,L             ; Get LSB of number
3326   35D2 CD 99 40            CALL    DIVSUP          ; Subt' divisor from dividend
3327   35D5 DE 00               SBC     A,0             ; Count for overflows
3328   35D7 3F                  CCF
3329   35D8 D2 E2 35            JP      NC,RESDIV       ; Restore divisor if borrow
3330   35DB 32 A5 40            LD      (DIV4),A        ; Re-save overflow count
3331   35DE F1                  POP     AF              ; Scrap divisor
3332   35DF F1                  POP     AF
3333   35E0 37                  SCF                     ; Set carry to
3334   35E1 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3335   35E2             
3336   35E2 C1          RESDIV: POP     BC              ; Restore divisor
3337   35E3 E1                  POP     HL
3338   35E4 79                  LD      A,C             ; Get MSB of quotient
3339   35E5 3C                  INC     A
3340   35E6 3D                  DEC     A
3341   35E7 1F                  RRA                     ; Bit 0 to bit 7
3342   35E8 FA 95 34            JP      M,RONDB         ; Done - Normalise result
3343   35EB 17                  RLA                     ; Restore carry
3344   35EC 7B                  LD      A,E             ; Get LSB of quotient
3345   35ED 17                  RLA                     ; Double it
3346   35EE 5F                  LD      E,A             ; Put it back
3347   35EF 7A                  LD      A,D             ; Get NMSB of quotient
3348   35F0 17                  RLA                     ; Double it
3349   35F1 57                  LD      D,A             ; Put it back
3350   35F2 79                  LD      A,C             ; Get MSB of quotient
3351   35F3 17                  RLA                     ; Double it
3352   35F4 4F                  LD      C,A             ; Put it back
3353   35F5 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3354   35F6 78                  LD      A,B             ; Get MSB of divisor
3355   35F7 17                  RLA                     ; Double it
3356   35F8 47                  LD      B,A             ; Put it back
3357   35F9 3A A5 40            LD      A,(DIV4)        ; Get VLSB of quotient
3358   35FC 17                  RLA                     ; Double it
3359   35FD 32 A5 40            LD      (DIV4),A        ; Put it back
3360   3600 79                  LD      A,C             ; Get MSB of quotient
3361   3601 B2                  OR      D               ; Merge NMSB
3362   3602 B3                  OR      E               ; Merge LSB
3363   3603 C2 CF 35            JP      NZ,DIVLP        ; Not done - Keep dividing
3364   3606 E5                  PUSH    HL              ; Save divisor
3365   3607 21 77 41            LD      HL,FPEXP        ; Point to exponent
3366   360A 35                  DEC     (HL)            ; Divide by 2
3367   360B E1                  POP     HL              ; Restore divisor
3368   360C C2 CF 35            JP      NZ,DIVLP        ; Ok - Keep going
3369   360F C3 BC 23            JP      OVERR           ; Overflow error
3370   3612             
3371   3612 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3372   3613 B7                  OR      A               ; Test it
3373   3614 CA 36 36            JP      Z,OVTST3        ; Zero - Result zero
3374   3617 7D                  LD      A,L             ; Get add/subtract flag
3375   3618 21 77 41            LD      HL,FPEXP        ; Point to exponent
3376   361B AE                  XOR     (HL)            ; Add or subtract it
3377   361C 80                  ADD     A,B             ; Add the other exponent
3378   361D 47                  LD      B,A             ; Save new exponent
3379   361E 1F                  RRA                     ; Test exponent for overflow
3380   361F A8                  XOR     B
3381   3620 78                  LD      A,B             ; Get exponent
3382   3621 F2 35 36            JP      P,OVTST2        ; Positive - Test for overflow
3383   3624 C6 80               ADD     A,80H           ; Add excess 128
3384   3626 77                  LD      (HL),A          ; Save new exponent
3385   3627 CA 95 35            JP      Z,POPHRT        ; Zero - Result zero
3386   362A CD BA 36            CALL    SIGNS           ; Set MSBs and sign of result
3387   362D 77                  LD      (HL),A          ; Save new exponent
3388   362E 2B                  DEC     HL              ; Point to MSB
3389   362F C9                  RET
3390   3630             
3391   3630 CD 54 36    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3392   3633 2F                  CPL                     ; Invert sign
3393   3634 E1                  POP     HL              ; Clean up stack
3394   3635 B7          OVTST2: OR      A               ; Test if new exponent zero
3395   3636 E1          OVTST3: POP     HL              ; Clear off return address
3396   3637 F2 74 34            JP      P,RESZER        ; Result zero
3397   363A C3 BC 23            JP      OVERR           ; Overflow error
3398   363D             
3399   363D CD A0 36    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3400   3640 78                  LD      A,B             ; Get exponent
3401   3641 B7                  OR      A               ; Is it zero?
3402   3642 C8                  RET     Z               ; Yes - Result is zero
3403   3643 C6 02               ADD     A,2             ; Multiply by 4
3404   3645 DA BC 23            JP      C,OVERR         ; Overflow - ?OV Error
3405   3648 47                  LD      B,A             ; Re-save exponent
3406   3649 CD 0E 34            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3407   364C 21 77 41            LD      HL,FPEXP        ; Point to exponent
3408   364F 34                  INC     (HL)            ; Double number (Times 10)
3409   3650 C0                  RET     NZ              ; Ok - Return
3410   3651 C3 BC 23            JP      OVERR           ; Overflow error
3411   3654             
3412   3654 3A 77 41    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3413   3657 B7                  OR      A
3414   3658 C8                  RET     Z               ; RETurn if number is zero
3415   3659 3A 76 41            LD      A,(FPREG+2)     ; Get MSB of FPREG
3416   365C FE                  .BYTE      0FEH            ; Test sign
3417   365D 2F          RETREL: CPL                     ; Invert sign
3418   365E 17                  RLA                     ; Sign bit to carry
3419   365F 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3420   3660 C0                  RET     NZ              ; Return -1 if negative
3421   3661 3C                  INC     A               ; Bump to +1
3422   3662 C9                  RET                     ; Positive - Return +1
3423   3663             
3424   3663 CD 54 36    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3425   3666 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3426   3668 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3427   366B 21 77 41    RETINT: LD      HL,FPEXP        ; Point to exponent
3428   366E 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3429   366F 70                  LD      (HL),B          ; Save exponent
3430   3670 06 00               LD      B,0             ; CDE = integer to normalise
3431   3672 23                  INC     HL              ; Point to sign of result
3432   3673 36 80               LD      (HL),80H        ; Set sign of result
3433   3675 17                  RLA                     ; Carry = sign of integer
3434   3676 C3 5C 34            JP      CONPOS          ; Set sign of result
3435   3679             
3436   3679 CD 54 36    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3437   367C F0                  RET     P               ; Return if positive
3438   367D 21 76 41    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3439   3680 7E                  LD      A,(HL)          ; Get sign of mantissa
3440   3681 EE 80               XOR     80H             ; Invert sign of mantissa
3441   3683 77                  LD      (HL),A          ; Re-save sign of mantissa
3442   3684 C9                  RET
3443   3685             
3444   3685 EB          STAKFP: EX      DE,HL           ; Save code string address
3445   3686 2A 74 41            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3446   3689 E3                  EX      (SP),HL         ; Stack them,get return
3447   368A E5                  PUSH    HL              ; Re-save return
3448   368B 2A 76 41            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3449   368E E3                  EX      (SP),HL         ; Stack them,get return
3450   368F E5                  PUSH    HL              ; Re-save return
3451   3690 EB                  EX      DE,HL           ; Restore code string address
3452   3691 C9                  RET
3453   3692             
3454   3692 CD A3 36    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3455   3695 EB          FPBCDE: EX      DE,HL           ; Save code string address
3456   3696 22 74 41            LD      (FPREG),HL      ; Save LSB,NLSB of number
3457   3699 60                  LD      H,B             ; Exponent of number
3458   369A 69                  LD      L,C             ; MSB of number
3459   369B 22 76 41            LD      (FPREG+2),HL    ; Save MSB and exponent
3460   369E EB                  EX      DE,HL           ; Restore code string address
3461   369F C9                  RET
3462   36A0             
3463   36A0 21 74 41    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3464   36A3 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3465   36A4 23                  INC     HL
3466   36A5 56                  LD      D,(HL)          ; Get NMSB of number
3467   36A6 23                  INC     HL
3468   36A7 4E                  LD      C,(HL)          ; Get MSB of number
3469   36A8 23                  INC     HL
3470   36A9 46                  LD      B,(HL)          ; Get exponent of number
3471   36AA 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3472   36AB C9                  RET
3473   36AC             
3474   36AC 11 74 41    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3475   36AF 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3476   36B1 1A          DETHLB: LD      A,(DE)          ; Get source
3477   36B2 77                  LD      (HL),A          ; Save destination
3478   36B3 13                  INC     DE              ; Next source
3479   36B4 23                  INC     HL              ; Next destination
3480   36B5 05                  DEC     B               ; Count bytes
3481   36B6 C2 B1 36            JP      NZ,DETHLB       ; Loop if more
3482   36B9 C9                  RET
3483   36BA             
3484   36BA 21 76 41    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3485   36BD 7E                  LD      A,(HL)          ; Get MSB
3486   36BE 07                  RLCA                    ; Old sign to carry
3487   36BF 37                  SCF                     ; Set MSBit
3488   36C0 1F                  RRA                     ; Set MSBit of MSB
3489   36C1 77                  LD      (HL),A          ; Save new MSB
3490   36C2 3F                  CCF                     ; Complement sign
3491   36C3 1F                  RRA                     ; Old sign to carry
3492   36C4 23                  INC     HL
3493   36C5 23                  INC     HL
3494   36C6 77                  LD      (HL),A          ; Set sign of result
3495   36C7 79                  LD      A,C             ; Get MSB
3496   36C8 07                  RLCA                    ; Old sign to carry
3497   36C9 37                  SCF                     ; Set MSBit
3498   36CA 1F                  RRA                     ; Set MSBit of MSB
3499   36CB 4F                  LD      C,A             ; Save MSB
3500   36CC 1F                  RRA
3501   36CD AE                  XOR     (HL)            ; New sign of result
3502   36CE C9                  RET
3503   36CF             
3504   36CF 78          CMPNUM: LD      A,B             ; Get exponent of number
3505   36D0 B7                  OR      A
3506   36D1 CA 54 36            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3507   36D4 21 5D 36            LD      HL,RETREL       ; Return relation routine
3508   36D7 E5                  PUSH    HL              ; Save for return
3509   36D8 CD 54 36            CALL    TSTSGN          ; Test sign of FPREG
3510   36DB 79                  LD      A,C             ; Get MSB of number
3511   36DC C8                  RET     Z               ; FPREG zero - Number's MSB
3512   36DD 21 76 41            LD      HL,FPREG+2      ; MSB of FPREG
3513   36E0 AE                  XOR     (HL)            ; Combine signs
3514   36E1 79                  LD      A,C             ; Get MSB of number
3515   36E2 F8                  RET     M               ; Exit if signs different
3516   36E3 CD E9 36            CALL    CMPFP           ; Compare FP numbers
3517   36E6 1F                  RRA                     ; Get carry to sign
3518   36E7 A9                  XOR     C               ; Combine with MSB of number
3519   36E8 C9                  RET
3520   36E9             
3521   36E9 23          CMPFP:  INC     HL              ; Point to exponent
3522   36EA 78                  LD      A,B             ; Get exponent
3523   36EB BE                  CP      (HL)            ; Compare exponents
3524   36EC C0                  RET     NZ              ; Different
3525   36ED 2B                  DEC     HL              ; Point to MBS
3526   36EE 79                  LD      A,C             ; Get MSB
3527   36EF BE                  CP      (HL)            ; Compare MSBs
3528   36F0 C0                  RET     NZ              ; Different
3529   36F1 2B                  DEC     HL              ; Point to NMSB
3530   36F2 7A                  LD      A,D             ; Get NMSB
3531   36F3 BE                  CP      (HL)            ; Compare NMSBs
3532   36F4 C0                  RET     NZ              ; Different
3533   36F5 2B                  DEC     HL              ; Point to LSB
3534   36F6 7B                  LD      A,E             ; Get LSB
3535   36F7 96                  SUB     (HL)            ; Compare LSBs
3536   36F8 C0                  RET     NZ              ; Different
3537   36F9 E1                  POP     HL              ; Drop RETurn
3538   36FA E1                  POP     HL              ; Drop another RETurn
3539   36FB C9                  RET
3540   36FC             
3541   36FC 47          FPINT:  LD      B,A             ; <- Move
3542   36FD 4F                  LD      C,A             ; <- exponent
3543   36FE 57                  LD      D,A             ; <- to all
3544   36FF 5F                  LD      E,A             ; <- bits
3545   3700 B7                  OR      A               ; Test exponent
3546   3701 C8                  RET     Z               ; Zero - Return zero
3547   3702 E5                  PUSH    HL              ; Save pointer to number
3548   3703 CD A0 36            CALL    BCDEFP          ; Move FPREG to BCDE
3549   3706 CD BA 36            CALL    SIGNS           ; Set MSBs & sign of result
3550   3709 AE                  XOR     (HL)            ; Combine with sign of FPREG
3551   370A 67                  LD      H,A             ; Save combined signs
3552   370B FC 20 37            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3553   370E 3E 98               LD      A,80H+24        ; 24 bits
3554   3710 90                  SUB     B               ; Bits to shift
3555   3711 CD D3 34            CALL    SCALE           ; Shift BCDE
3556   3714 7C                  LD      A,H             ; Get combined sign
3557   3715 17                  RLA                     ; Sign to carry
3558   3716 DC A6 34            CALL    C,FPROND        ; Negative - Round number up
3559   3719 06 00               LD      B,0             ; Zero exponent
3560   371B DC BF 34            CALL    C,COMPL         ; If negative make positive
3561   371E E1                  POP     HL              ; Restore pointer to number
3562   371F C9                  RET
3563   3720             
3564   3720 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3565   3721 7A                  LD      A,D             ; Test LSBs
3566   3722 A3                  AND     E
3567   3723 3C                  INC     A
3568   3724 C0                  RET     NZ              ; Exit if LSBs not FFFF
3569   3725 0B                  DEC     BC              ; Decrement MSBs
3570   3726 C9                  RET
3571   3727             
3572   3727 21 77 41    INT:    LD      HL,FPEXP        ; Point to exponent
3573   372A 7E                  LD      A,(HL)          ; Get exponent
3574   372B FE 98               CP      80H+24          ; Integer accuracy only?
3575   372D 3A 74 41            LD      A,(FPREG)       ; Get LSB
3576   3730 D0                  RET     NC              ; Yes - Already integer
3577   3731 7E                  LD      A,(HL)          ; Get exponent
3578   3732 CD FC 36            CALL    FPINT           ; F.P to integer
3579   3735 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3580   3737 7B                  LD      A,E             ; Get LSB of number
3581   3738 F5                  PUSH    AF              ; Save LSB
3582   3739 79                  LD      A,C             ; Get MSB of number
3583   373A 17                  RLA                     ; Sign to carry
3584   373B CD 5C 34            CALL    CONPOS          ; Set sign of result
3585   373E F1                  POP     AF              ; Restore LSB of number
3586   373F C9                  RET
3587   3740             
3588   3740 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3589   3743 78                  LD      A,B             ; Test multiplier
3590   3744 B1                  OR      C
3591   3745 C8                  RET     Z               ; Return zero if zero
3592   3746 3E 10               LD      A,16            ; 16 bits
3593   3748 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3594   3749 DA 80 2F            JP      C,BSERR         ; ?BS Error if overflow
3595   374C EB                  EX      DE,HL
3596   374D 29                  ADD     HL,HL           ; Shift multiplier left
3597   374E EB                  EX      DE,HL
3598   374F D2 56 37            JP      NC,NOMLAD       ; Bit was zero - No add
3599   3752 09                  ADD     HL,BC           ; Add multiplicand
3600   3753 DA 80 2F            JP      C,BSERR         ; ?BS Error if overflow
3601   3756 3D          NOMLAD: DEC     A               ; Count bits
3602   3757 C2 48 37            JP      NZ,MLDBLP       ; More
3603   375A C9                  RET
3604   375B             
3605   375B FE 2D       ASCTFP: CP      '-'             ; Negative?
3606   375D F5                  PUSH    AF              ; Save it and flags
3607   375E CA 67 37            JP      Z,CNVNUM        ; Yes - Convert number
3608   3761 FE 2B               CP      '+'             ; Positive?
3609   3763 CA 67 37            JP      Z,CNVNUM        ; Yes - Convert number
3610   3766 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3611   3767 CD 74 34    CNVNUM: CALL    RESZER          ; Set result to zero
3612   376A 47                  LD      B,A             ; Digits after point counter
3613   376B 57                  LD      D,A             ; Sign of exponent
3614   376C 5F                  LD      E,A             ; Exponent of ten
3615   376D 2F                  CPL
3616   376E 4F                  LD      C,A             ; Before or after point flag
3617   376F CD 05 28    MANLP:  CALL    GETCHR          ; Get next character
3618   3772 DA B8 37            JP      C,ADDIG         ; Digit - Add to number
3619   3775 FE 2E               CP      '.'
3620   3777 CA 93 37            JP      Z,DPOINT        ; '.' - Flag point
3621   377A FE 45               CP      'E'
3622   377C C2 97 37            JP      NZ,CONEXP       ; Not 'E' - Scale number
3623   377F CD 05 28            CALL    GETCHR          ; Get next character
3624   3782 CD AB 2D            CALL    SGNEXP          ; Get sign of exponent
3625   3785 CD 05 28    EXPLP:  CALL    GETCHR          ; Get next character
3626   3788 DA DA 37            JP      C,EDIGIT        ; Digit - Add to exponent
3627   378B 14                  INC     D               ; Is sign negative?
3628   378C C2 97 37            JP      NZ,CONEXP       ; No - Scale number
3629   378F AF                  XOR     A
3630   3790 93                  SUB     E               ; Negate exponent
3631   3791 5F                  LD      E,A             ; And re-save it
3632   3792 0C                  INC     C               ; Flag end of number
3633   3793 0C          DPOINT: INC     C               ; Flag point passed
3634   3794 CA 6F 37            JP      Z,MANLP         ; Zero - Get another digit
3635   3797 E5          CONEXP: PUSH    HL              ; Save code string address
3636   3798 7B                  LD      A,E             ; Get exponent
3637   3799 90                  SUB     B               ; Subtract digits after point
3638   379A F4 B0 37    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3639   379D F2 A6 37            JP      P,ENDCON        ; Positive - All done
3640   37A0 F5                  PUSH    AF              ; Save number of times to /10
3641   37A1 CD 9C 35            CALL    DIV10           ; Divide by 10
3642   37A4 F1                  POP     AF              ; Restore count
3643   37A5 3C                  INC     A               ; Count divides
3644   37A6             
3645   37A6 C2 9A 37    ENDCON: JP      NZ,SCALMI       ; More to do
3646   37A9 D1                  POP     DE              ; Restore code string address
3647   37AA F1                  POP     AF              ; Restore sign of number
3648   37AB CC 7D 36            CALL    Z,INVSGN        ; Negative - Negate number
3649   37AE EB                  EX      DE,HL           ; Code string address to HL
3650   37AF C9                  RET
3651   37B0             
3652   37B0 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3653   37B1 F5          MULTEN: PUSH    AF              ; Save count
3654   37B2 CD 3D 36            CALL    MLSP10          ; Multiply number by 10
3655   37B5 F1                  POP     AF              ; Restore count
3656   37B6 3D                  DEC     A               ; Count multiplies
3657   37B7 C9                  RET
3658   37B8             
3659   37B8 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3660   37B9 57                  LD      D,A             ; Save digit
3661   37BA 78                  LD      A,B             ; Get digits after point
3662   37BB 89                  ADC     A,C             ; Add one if after point
3663   37BC 47                  LD      B,A             ; Re-save counter
3664   37BD C5                  PUSH    BC              ; Save point flags
3665   37BE E5                  PUSH    HL              ; Save code string address
3666   37BF D5                  PUSH    DE              ; Save digit
3667   37C0 CD 3D 36            CALL    MLSP10          ; Multiply number by 10
3668   37C3 F1                  POP     AF              ; Restore digit
3669   37C4 D6 30               SUB     '0'             ; Make it absolute
3670   37C6 CD CF 37            CALL    RSCALE          ; Re-scale number
3671   37C9 E1                  POP     HL              ; Restore code string address
3672   37CA C1                  POP     BC              ; Restore point flags
3673   37CB D1                  POP     DE              ; Restore sign of exponent
3674   37CC C3 6F 37            JP      MANLP           ; Get another digit
3675   37CF             
3676   37CF CD 85 36    RSCALE: CALL    STAKFP          ; Put number on stack
3677   37D2 CD 66 36            CALL    FLGREL          ; Digit to add to FPREG
3678   37D5 C1          PADD:   POP     BC              ; Restore number
3679   37D6 D1                  POP     DE
3680   37D7 C3 0E 34            JP      FPADD           ; Add BCDE to FPREG and return
3681   37DA             
3682   37DA 7B          EDIGIT: LD      A,E             ; Get digit
3683   37DB 07                  RLCA                    ; Times 2
3684   37DC 07                  RLCA                    ; Times 4
3685   37DD 83                  ADD     A,E             ; Times 5
3686   37DE 07                  RLCA                    ; Times 10
3687   37DF 86                  ADD     A,(HL)          ; Add next digit
3688   37E0 D6 30               SUB     '0'             ; Make it absolute
3689   37E2 5F                  LD      E,A             ; Save new digit
3690   37E3 C3 85 37            JP      EXPLP           ; Look for another digit
3691   37E6             
3692   37E6 E5          LINEIN: PUSH    HL              ; Save code string address
3693   37E7 21 45 23            LD      HL,INMSG        ; Output " in "
3694   37EA CD 4B 31            CALL    PRS             ; Output string at HL
3695   37ED E1                  POP     HL              ; Restore code string address
3696   37EE EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3697   37EF AF                  XOR     A
3698   37F0 06 98               LD      B,80H+24        ; 24 bits
3699   37F2 CD 6B 36            CALL    RETINT          ; Return the integer
3700   37F5 21 4A 31            LD      HL,PRNUMS       ; Print number string
3701   37F8 E5                  PUSH    HL              ; Save for return
3702   37F9 21 79 41    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3703   37FC E5                  PUSH    HL              ; Save for return
3704   37FD CD 54 36            CALL    TSTSGN          ; Test sign of FPREG
3705   3800 36 20               LD      (HL),' '        ; Space at start
3706   3802 F2 07 38            JP      P,SPCFST        ; Positive - Space to start
3707   3805 36 2D               LD      (HL),'-'        ; '-' sign at start
3708   3807 23          SPCFST: INC     HL              ; First byte of number
3709   3808 36 30               LD      (HL),'0'        ; '0' if zero
3710   380A CA BD 38            JP      Z,JSTZER        ; Return '0' if zero
3711   380D E5                  PUSH    HL              ; Save buffer address
3712   380E FC 7D 36            CALL    M,INVSGN        ; Negate FPREG if negative
3713   3811 AF                  XOR     A               ; Zero A
3714   3812 F5                  PUSH    AF              ; Save it
3715   3813 CD C3 38            CALL    RNGTST          ; Test number is in range
3716   3816 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3717   3819 11 F8 4F            LD      DE,4FF8H
3718   381C CD CF 36            CALL    CMPNUM          ; Compare numbers
3719   381F B7                  OR      A
3720   3820 E2 34 38            JP      PO,INRNG        ; > 99999.9 - Sort it out
3721   3823 F1                  POP     AF              ; Restore count
3722   3824 CD B1 37            CALL    MULTEN          ; Multiply by ten
3723   3827 F5                  PUSH    AF              ; Re-save count
3724   3828 C3 16 38            JP      SIXDIG          ; Test it again
3725   382B             
3726   382B CD 9C 35    GTSIXD: CALL    DIV10           ; Divide by 10
3727   382E F1                  POP     AF              ; Get count
3728   382F 3C                  INC     A               ; Count divides
3729   3830 F5                  PUSH    AF              ; Re-save count
3730   3831 CD C3 38            CALL    RNGTST          ; Test number is in range
3731   3834 CD FC 33    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3732   3837 3C                  INC     A
3733   3838 CD FC 36            CALL    FPINT           ; F.P to integer
3734   383B CD 95 36            CALL    FPBCDE          ; Move BCDE to FPREG
3735   383E 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3736   3841 F1                  POP     AF              ; Restore count
3737   3842 81                  ADD     A,C             ; 6 digits before point
3738   3843 3C                  INC     A               ; Add one
3739   3844 FA 50 38            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3740   3847 FE 08               CP      6+1+1           ; More than 999999 ?
3741   3849 D2 50 38            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3742   384C 3C                  INC     A               ; Adjust for exponent
3743   384D 47                  LD      B,A             ; Exponent of number
3744   384E 3E 02               LD      A,2             ; Make it zero after
3745   3850             
3746   3850 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3747   3851 3D                  DEC     A
3748   3852 E1                  POP     HL              ; Restore buffer address
3749   3853 F5                  PUSH    AF              ; Save count
3750   3854 11 D6 38            LD      DE,POWERS       ; Powers of ten
3751   3857 05                  DEC     B               ; Count digits before point
3752   3858 C2 61 38            JP      NZ,DIGTXT       ; Not zero - Do number
3753   385B 36 2E               LD      (HL),'.'        ; Save point
3754   385D 23                  INC     HL              ; Move on
3755   385E 36 30               LD      (HL),'0'        ; Save zero
3756   3860 23                  INC     HL              ; Move on
3757   3861 05          DIGTXT: DEC     B               ; Count digits before point
3758   3862 36 2E               LD      (HL),'.'        ; Save point in case
3759   3864 CC AA 36            CALL    Z,INCHL         ; Last digit - move on
3760   3867 C5                  PUSH    BC              ; Save digits before point
3761   3868 E5                  PUSH    HL              ; Save buffer address
3762   3869 D5                  PUSH    DE              ; Save powers of ten
3763   386A CD A0 36            CALL    BCDEFP          ; Move FPREG to BCDE
3764   386D E1                  POP     HL              ; Powers of ten table
3765   386E 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3766   3870 04          TRYAGN: INC     B               ; Count subtractions
3767   3871 7B                  LD      A,E             ; Get LSB
3768   3872 96                  SUB     (HL)            ; Subtract LSB
3769   3873 5F                  LD      E,A             ; Save LSB
3770   3874 23                  INC     HL
3771   3875 7A                  LD      A,D             ; Get NMSB
3772   3876 9E                  SBC     A,(HL)          ; Subtract NMSB
3773   3877 57                  LD      D,A             ; Save NMSB
3774   3878 23                  INC     HL
3775   3879 79                  LD      A,C             ; Get MSB
3776   387A 9E                  SBC     A,(HL)          ; Subtract MSB
3777   387B 4F                  LD      C,A             ; Save MSB
3778   387C 2B                  DEC     HL              ; Point back to start
3779   387D 2B                  DEC     HL
3780   387E D2 70 38            JP      NC,TRYAGN       ; No overflow - Try again
3781   3881 CD B3 34            CALL    PLUCDE          ; Restore number
3782   3884 23                  INC     HL              ; Start of next number
3783   3885 CD 95 36            CALL    FPBCDE          ; Move BCDE to FPREG
3784   3888 EB                  EX      DE,HL           ; Save point in table
3785   3889 E1                  POP     HL              ; Restore buffer address
3786   388A 70                  LD      (HL),B          ; Save digit in buffer
3787   388B 23                  INC     HL              ; And move on
3788   388C C1                  POP     BC              ; Restore digit count
3789   388D 0D                  DEC     C               ; Count digits
3790   388E C2 61 38            JP      NZ,DIGTXT       ; More - Do them
3791   3891 05                  DEC     B               ; Any decimal part?
3792   3892 CA A1 38            JP      Z,DOEBIT        ; No - Do 'E' bit
3793   3895 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3794   3896 7E                  LD      A,(HL)          ; Get character
3795   3897 FE 30               CP      '0'             ; '0' character?
3796   3899 CA 95 38            JP      Z,SUPTLZ        ; Yes - Look back for more
3797   389C FE 2E               CP      '.'             ; A decimal point?
3798   389E C4 AA 36            CALL    NZ,INCHL        ; Move back over digit
3799   38A1             
3800   38A1 F1          DOEBIT: POP     AF              ; Get 'E' flag
3801   38A2 CA C0 38            JP      Z,NOENED        ; No 'E' needed - End buffer
3802   38A5 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3803   38A7 23                  INC     HL              ; And move on
3804   38A8 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3805   38AA F2 B1 38            JP      P,OUTEXP        ; Positive - Output exponent
3806   38AD 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3807   38AF 2F                  CPL                     ; Negate exponent
3808   38B0 3C                  INC     A
3809   38B1 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3810   38B3 04          EXPTEN: INC     B               ; Count subtractions
3811   38B4 D6 0A               SUB     10              ; Tens digit
3812   38B6 D2 B3 38            JP      NC,EXPTEN       ; More to do
3813   38B9 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3814   38BB 23                  INC     HL              ; Move on
3815   38BC 70                  LD      (HL),B          ; Save MSB of exponent
3816   38BD 23          JSTZER: INC     HL              ;
3817   38BE 77                  LD      (HL),A          ; Save LSB of exponent
3818   38BF 23                  INC     HL
3819   38C0 71          NOENED: LD      (HL),C          ; Mark end of buffer
3820   38C1 E1                  POP     HL              ; Restore code string address
3821   38C2 C9                  RET
3822   38C3             
3823   38C3 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3824   38C6 11 F7 23            LD      DE,23F7H
3825   38C9 CD CF 36            CALL    CMPNUM          ; Compare numbers
3826   38CC B7                  OR      A
3827   38CD E1                  POP     HL              ; Return address to HL
3828   38CE E2 2B 38            JP      PO,GTSIXD       ; Too big - Divide by ten
3829   38D1 E9                  JP      (HL)            ; Otherwise return to caller
3830   38D2             
3831   38D2 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3832   38D6             
3833   38D6 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3834   38D9 10 27 00            .BYTE      010H,027H,000H  ;  10000
3835   38DC E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3836   38DF 64 00 00            .BYTE      064H,000H,000H  ;    100
3837   38E2 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3838   38E5 01 00 00            .BYTE      001H,000H,000H  ;      1
3839   38E8             
3840   38E8 21 7D 36    NEGAFT: LD  HL,INVSGN           ; Negate result
3841   38EB E3                  EX      (SP),HL         ; To be done after caller
3842   38EC E9                  JP      (HL)            ; Return to caller
3843   38ED             
3844   38ED CD 85 36    SQR:    CALL    STAKFP          ; Put value on stack
3845   38F0 21 D2 38            LD      HL,HALF         ; Set power to 1/2
3846   38F3 CD 92 36            CALL    PHLTFP          ; Move 1/2 to FPREG
3847   38F6             
3848   38F6 C1          POWER:  POP     BC              ; Get base
3849   38F7 D1                  POP     DE
3850   38F8 CD 54 36            CALL    TSTSGN          ; Test sign of power
3851   38FB 78                  LD      A,B             ; Get exponent of base
3852   38FC CA 3B 39            JP      Z,EXP           ; Make result 1 if zero
3853   38FF F2 06 39            JP      P,POWER1        ; Positive base - Ok
3854   3902 B7                  OR      A               ; Zero to negative power?
3855   3903 CA B0 23            JP      Z,DZERR         ; Yes - ?/0 Error
3856   3906 B7          POWER1: OR      A               ; Base zero?
3857   3907 CA 75 34            JP      Z,SAVEXP        ; Yes - Return zero
3858   390A D5                  PUSH    DE              ; Save base
3859   390B C5                  PUSH    BC
3860   390C 79                  LD      A,C             ; Get MSB of base
3861   390D F6 7F               OR      01111111B       ; Get sign status
3862   390F CD A0 36            CALL    BCDEFP          ; Move power to BCDE
3863   3912 F2 23 39            JP      P,POWER2        ; Positive base - Ok
3864   3915 D5                  PUSH    DE              ; Save power
3865   3916 C5                  PUSH    BC
3866   3917 CD 27 37            CALL    INT             ; Get integer of power
3867   391A C1                  POP     BC              ; Restore power
3868   391B D1                  POP     DE
3869   391C F5                  PUSH    AF              ; MSB of base
3870   391D CD CF 36            CALL    CMPNUM          ; Power an integer?
3871   3920 E1                  POP     HL              ; Restore MSB of base
3872   3921 7C                  LD      A,H             ; but don't affect flags
3873   3922 1F                  RRA                     ; Exponent odd or even?
3874   3923 E1          POWER2: POP     HL              ; Restore MSB and exponent
3875   3924 22 76 41            LD      (FPREG+2),HL    ; Save base in FPREG
3876   3927 E1                  POP     HL              ; LSBs of base
3877   3928 22 74 41            LD      (FPREG),HL      ; Save in FPREG
3878   392B DC E8 38            CALL    C,NEGAFT        ; Odd power - Negate result
3879   392E CC 7D 36            CALL    Z,INVSGN        ; Negative base - Negate it
3880   3931 D5                  PUSH    DE              ; Save power
3881   3932 C5                  PUSH    BC
3882   3933 CD 08 35            CALL    LOG             ; Get LOG of base
3883   3936 C1                  POP     BC              ; Restore power
3884   3937 D1                  POP     DE
3885   3938 CD 49 35            CALL    FPMULT          ; Multiply LOG by power
3886   393B             
3887   393B CD 85 36    EXP:    CALL    STAKFP          ; Put value on stack
3888   393E 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3889   3941 11 3B AA            LD      DE,0AA3BH
3890   3944 CD 49 35            CALL    FPMULT          ; Multiply value by 1/LN(2)
3891   3947 3A 77 41            LD      A,(FPEXP)       ; Get exponent
3892   394A FE 88               CP      80H+8           ; Is it in range?
3893   394C D2 30 36            JP      NC,OVTST1       ; No - Test for overflow
3894   394F CD 27 37            CALL    INT             ; Get INT of FPREG
3895   3952 C6 80               ADD     A,80H           ; For excess 128
3896   3954 C6 02               ADD     A,2             ; Exponent > 126?
3897   3956 DA 30 36            JP      C,OVTST1        ; Yes - Test for overflow
3898   3959 F5                  PUSH    AF              ; Save scaling factor
3899   395A 21 F7 34            LD      HL,UNITY        ; Point to 1.
3900   395D CD FF 33            CALL    ADDPHL          ; Add 1 to FPREG
3901   3960 CD 40 35            CALL    MULLN2          ; Multiply by LN(2)
3902   3963 F1                  POP     AF              ; Restore scaling factor
3903   3964 C1                  POP     BC              ; Restore exponent
3904   3965 D1                  POP     DE
3905   3966 F5                  PUSH    AF              ; Save scaling factor
3906   3967 CD 0B 34            CALL    SUBCDE          ; Subtract exponent from FPREG
3907   396A CD 7D 36            CALL    INVSGN          ; Negate result
3908   396D 21 7B 39            LD      HL,EXPTAB       ; Coefficient table
3909   3970 CD AB 39            CALL    SMSER1          ; Sum the series
3910   3973 11 00 00            LD      DE,0            ; Zero LSBs
3911   3976 C1                  POP     BC              ; Scaling factor
3912   3977 4A                  LD      C,D             ; Zero MSB
3913   3978 C3 49 35            JP      FPMULT          ; Scale result to correct value
3914   397B             
3915   397B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3916   397C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3917   3980 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3918   3984 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3919   3988 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3920   398C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3921   3990 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3922   3994 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3923   3998 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3924   399C             
3925   399C CD 85 36    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3926   399F 11 47 35            LD      DE,MULT         ; Multiply by "X"
3927   39A2 D5                  PUSH    DE              ; To be done after
3928   39A3 E5                  PUSH    HL              ; Save address of table
3929   39A4 CD A0 36            CALL    BCDEFP          ; Move FPREG to BCDE
3930   39A7 CD 49 35            CALL    FPMULT          ; Square the value
3931   39AA E1                  POP     HL              ; Restore address of table
3932   39AB CD 85 36    SMSER1: CALL    STAKFP          ; Put value on stack
3933   39AE 7E                  LD      A,(HL)          ; Get number of coefficients
3934   39AF 23                  INC     HL              ; Point to start of table
3935   39B0 CD 92 36            CALL    PHLTFP          ; Move coefficient to FPREG
3936   39B3 06                  .BYTE      06H             ; Skip "POP AF"
3937   39B4 F1          SUMLP:  POP     AF              ; Restore count
3938   39B5 C1                  POP     BC              ; Restore number
3939   39B6 D1                  POP     DE
3940   39B7 3D                  DEC     A               ; Cont coefficients
3941   39B8 C8                  RET     Z               ; All done
3942   39B9 D5                  PUSH    DE              ; Save number
3943   39BA C5                  PUSH    BC
3944   39BB F5                  PUSH    AF              ; Save count
3945   39BC E5                  PUSH    HL              ; Save address in table
3946   39BD CD 49 35            CALL    FPMULT          ; Multiply FPREG by BCDE
3947   39C0 E1                  POP     HL              ; Restore address in table
3948   39C1 CD A3 36            CALL    LOADFP          ; Number at HL to BCDE
3949   39C4 E5                  PUSH    HL              ; Save address in table
3950   39C5 CD 0E 34            CALL    FPADD           ; Add coefficient to FPREG
3951   39C8 E1                  POP     HL              ; Restore address in table
3952   39C9 C3 B4 39            JP      SUMLP           ; More coefficients
3953   39CC             
3954   39CC CD 54 36    RND:    CALL    TSTSGN          ; Test sign of FPREG
3955   39CF 21 A9 40            LD      HL,SEED+2       ; Random number seed
3956   39D2 FA 2D 3A            JP      M,RESEED        ; Negative - Re-seed
3957   39D5 21 CA 40            LD      HL,LSTRND       ; Last random number
3958   39D8 CD 92 36            CALL    PHLTFP          ; Move last RND to FPREG
3959   39DB 21 A9 40            LD      HL,SEED+2       ; Random number seed
3960   39DE C8                  RET     Z               ; Return if RND(0)
3961   39DF 86                  ADD     A,(HL)          ; Add (SEED)+2)
3962   39E0 E6 07               AND     00000111B       ; 0 to 7
3963   39E2 06 00               LD      B,0
3964   39E4 77                  LD      (HL),A          ; Re-save seed
3965   39E5 23                  INC     HL              ; Move to coefficient table
3966   39E6 87                  ADD     A,A             ; 4 bytes
3967   39E7 87                  ADD     A,A             ; per entry
3968   39E8 4F                  LD      C,A             ; BC = Offset into table
3969   39E9 09                  ADD     HL,BC           ; Point to coefficient
3970   39EA CD A3 36            CALL    LOADFP          ; Coefficient to BCDE
3971   39ED CD 49 35            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3972   39F0 3A A8 40            LD      A,(SEED+1)      ; Get (SEED+1)
3973   39F3 3C                  INC     A               ; Add 1
3974   39F4 E6 03               AND     00000011B       ; 0 to 3
3975   39F6 06 00               LD      B,0
3976   39F8 FE 01               CP      1               ; Is it zero?
3977   39FA 88                  ADC     A,B             ; Yes - Make it 1
3978   39FB 32 A8 40            LD      (SEED+1),A      ; Re-save seed
3979   39FE 21 31 3A            LD      HL,RNDTAB-4     ; Addition table
3980   3A01 87                  ADD     A,A             ; 4 bytes
3981   3A02 87                  ADD     A,A             ; per entry
3982   3A03 4F                  LD      C,A             ; BC = Offset into table
3983   3A04 09                  ADD     HL,BC           ; Point to value
3984   3A05 CD FF 33            CALL    ADDPHL          ; Add value to FPREG
3985   3A08 CD A0 36    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3986   3A0B 7B                  LD      A,E             ; Get LSB
3987   3A0C 59                  LD      E,C             ; LSB = MSB
3988   3A0D EE 4F               XOR     01001111B       ; Fiddle around
3989   3A0F 4F                  LD      C,A             ; New MSB
3990   3A10 36 80               LD      (HL),80H        ; Set exponent
3991   3A12 2B                  DEC     HL              ; Point to MSB
3992   3A13 46                  LD      B,(HL)          ; Get MSB
3993   3A14 36 80               LD      (HL),80H        ; Make value -0.5
3994   3A16 21 A7 40            LD      HL,SEED         ; Random number seed
3995   3A19 34                  INC     (HL)            ; Count seed
3996   3A1A 7E                  LD      A,(HL)          ; Get seed
3997   3A1B D6 AB               SUB     171             ; Do it modulo 171
3998   3A1D C2 24 3A            JP      NZ,RND2         ; Non-zero - Ok
3999   3A20 77                  LD      (HL),A          ; Zero seed
4000   3A21 0C                  INC     C               ; Fillde about
4001   3A22 15                  DEC     D               ; with the
4002   3A23 1C                  INC     E               ; number
4003   3A24 CD 5F 34    RND2:   CALL    BNORM           ; Normalise number
4004   3A27 21 CA 40            LD      HL,LSTRND       ; Save random number
4005   3A2A C3 AC 36            JP      FPTHL           ; Move FPREG to last and return
4006   3A2D             
4007   3A2D 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4008   3A2E 2B                  DEC     HL
4009   3A2F 77                  LD      (HL),A
4010   3A30 2B                  DEC     HL
4011   3A31 77                  LD      (HL),A
4012   3A32 C3 08 3A            JP      RND1            ; Return RND seed
4013   3A35             
4014   3A35 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4015   3A39 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4016   3A3D 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4017   3A41             
4018   3A41 21 8B 3A    COS:    LD      HL,HALFPI       ; Point to PI/2
4019   3A44 CD FF 33            CALL    ADDPHL          ; Add it to PPREG
4020   3A47 CD 85 36    SIN:    CALL    STAKFP          ; Put angle on stack
4021   3A4A 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4022   3A4D 11 DB 0F            LD      DE,0FDBH
4023   3A50 CD 95 36            CALL    FPBCDE          ; Move 2 PI to FPREG
4024   3A53 C1                  POP     BC              ; Restore angle
4025   3A54 D1                  POP     DE
4026   3A55 CD AA 35            CALL    DVBCDE          ; Divide angle by 2 PI
4027   3A58 CD 85 36            CALL    STAKFP          ; Put it on stack
4028   3A5B CD 27 37            CALL    INT             ; Get INT of result
4029   3A5E C1                  POP     BC              ; Restore number
4030   3A5F D1                  POP     DE
4031   3A60 CD 0B 34            CALL    SUBCDE          ; Make it 0 <= value < 1
4032   3A63 21 8F 3A            LD      HL,QUARTR       ; Point to 0.25
4033   3A66 CD 05 34            CALL    SUBPHL          ; Subtract value from 0.25
4034   3A69 CD 54 36            CALL    TSTSGN          ; Test sign of value
4035   3A6C 37                  SCF                     ; Flag positive
4036   3A6D F2 77 3A            JP      P,SIN1          ; Positive - Ok
4037   3A70 CD FC 33            CALL    ROUND           ; Add 0.5 to value
4038   3A73 CD 54 36            CALL    TSTSGN          ; Test sign of value
4039   3A76 B7                  OR      A               ; Flag negative
4040   3A77 F5          SIN1:   PUSH    AF              ; Save sign
4041   3A78 F4 7D 36            CALL    P,INVSGN        ; Negate value if positive
4042   3A7B 21 8F 3A            LD      HL,QUARTR       ; Point to 0.25
4043   3A7E CD FF 33            CALL    ADDPHL          ; Add 0.25 to value
4044   3A81 F1                  POP     AF              ; Restore sign
4045   3A82 D4 7D 36            CALL    NC,INVSGN       ; Negative - Make positive
4046   3A85 21 93 3A            LD      HL,SINTAB       ; Coefficient table
4047   3A88 C3 9C 39            JP      SUMSER          ; Evaluate sum of series
4048   3A8B             
4049   3A8B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4050   3A8F             
4051   3A8F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4052   3A93             
4053   3A93 05          SINTAB: .BYTE   5                       ; Table used by SIN
4054   3A94 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4055   3A98 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4056   3A9C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4057   3AA0 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4058   3AA4 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4059   3AA8             
4060   3AA8 CD 85 36    TAN:    CALL    STAKFP          ; Put angle on stack
4061   3AAB CD 47 3A            CALL    SIN             ; Get SIN of angle
4062   3AAE C1                  POP     BC              ; Restore angle
4063   3AAF E1                  POP     HL
4064   3AB0 CD 85 36            CALL    STAKFP          ; Save SIN of angle
4065   3AB3 EB                  EX      DE,HL           ; BCDE = Angle
4066   3AB4 CD 95 36            CALL    FPBCDE          ; Angle to FPREG
4067   3AB7 CD 41 3A            CALL    COS             ; Get COS of angle
4068   3ABA C3 A8 35            JP      DIV             ; TAN = SIN / COS
4069   3ABD             
4070   3ABD CD 54 36    ATN:    CALL    TSTSGN          ; Test sign of value
4071   3AC0 FC E8 38            CALL    M,NEGAFT        ; Negate result after if -ve
4072   3AC3 FC 7D 36            CALL    M,INVSGN        ; Negate value if -ve
4073   3AC6 3A 77 41            LD      A,(FPEXP)       ; Get exponent
4074   3AC9 FE 81               CP      81H             ; Number less than 1?
4075   3ACB DA DA 3A            JP      C,ATN1          ; Yes - Get arc tangnt
4076   3ACE 01 00 81            LD      BC,8100H        ; BCDE = 1
4077   3AD1 51                  LD      D,C
4078   3AD2 59                  LD      E,C
4079   3AD3 CD AA 35            CALL    DVBCDE          ; Get reciprocal of number
4080   3AD6 21 05 34            LD      HL,SUBPHL       ; Sub angle from PI/2
4081   3AD9 E5                  PUSH    HL              ; Save for angle > 1
4082   3ADA 21 E4 3A    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4083   3ADD CD 9C 39            CALL    SUMSER          ; Evaluate sum of series
4084   3AE0 21 8B 3A            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4085   3AE3 C9                  RET                     ; Number > 1 - Sub from PI/2
4086   3AE4             
4087   3AE4 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4088   3AE5 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4089   3AE9 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4090   3AED FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4091   3AF1 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4092   3AF5 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4093   3AF9 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4094   3AFD E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4095   3B01 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4096   3B05 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4097   3B09             
4098   3B09             
4099   3B09 C9          ARET:   RET                     ; A RETurn instruction
4100   3B0A             
4101   3B0A D7          GETINP: RST	    10H             ;input a character
4102   3B0B C9                  RET
4103   3B0C             
4104   3B0C             CLS: 
4105   3B0C 3E 0C               LD      A,CS            ; ASCII Clear screen
4106   3B0E C3 46 3C            JP      MONOUT          ; Output character
4107   3B11             
4108   3B11 CD D3 33    WIDTH:  CALL    GETINT          ; Get integer 0-255
4109   3B14 7B                  LD      A,E             ; Width to A
4110   3B15 32 D2 40            LD      (LWIDTH),A      ; Set width
4111   3B18 C9                  RET
4112   3B19             
4113   3B19 CD 72 2C    LINES:  CALL    GETNUM          ; Get a number
4114   3B1C CD B7 28            CALL    DEINT           ; Get integer -32768 to 32767
4115   3B1F ED 53 D6 40         LD      (LINESC),DE     ; Set lines counter
4116   3B23 ED 53 D8 40         LD      (LINESN),DE     ; Set lines number
4117   3B27 C9                  RET
4118   3B28             
4119   3B28 CD B7 28    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4120   3B2B D5                  PUSH    DE              ; Save number
4121   3B2C E1                  POP     HL              ; Number to HL
4122   3B2D 46                  LD      B,(HL)          ; Get LSB of contents
4123   3B2E 23                  INC     HL
4124   3B2F 7E                  LD      A,(HL)          ; Get MSB of contents
4125   3B30 C3 2D 30            JP      ABPASS          ; Return integer AB
4126   3B33             
4127   3B33 CD 72 2C    DOKE:   CALL    GETNUM          ; Get a number
4128   3B36 CD B7 28            CALL    DEINT           ; Get integer -32768 to 32767
4129   3B39 D5                  PUSH    DE              ; Save address
4130   3B3A CD 7B 26            CALL    CHKSYN          ; Make sure ',' follows
4131   3B3D 2C                  .BYTE      ','
4132   3B3E CD 72 2C            CALL    GETNUM          ; Get a number
4133   3B41 CD B7 28            CALL    DEINT           ; Get integer -32768 to 32767
4134   3B44 E3                  EX      (SP),HL         ; Save value,get address
4135   3B45 73                  LD      (HL),E          ; Save LSB of value
4136   3B46 23                  INC     HL
4137   3B47 72                  LD      (HL),D          ; Save MSB of value
4138   3B48 E1                  POP     HL              ; Restore code string address
4139   3B49 C9                  RET
4140   3B4A             
4141   3B4A             
4142   3B4A             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4143   3B4A             
4144   3B4A CD 75 2C    HEX: 	CALL	TSTNUM          ; Verify it's a number
4145   3B4D CD B7 28            CALL	DEINT           ; Get integer -32768 to 32767
4146   3B50 C5                  PUSH	BC              ; Save contents of BC
4147   3B51 21 79 41            LD	    HL,PBUFF
4148   3B54 7A                  LD	    A,D             ; Get high order into A
4149   3B55 FE 00               CP      $0
4150   3B57 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4151   3B59 CD 82 3B            CALL    BYT2ASC         ; Convert D to ASCII
4152   3B5C 78          		LD      A,B
4153   3B5D FE 30       		CP      '0'
4154   3B5F 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4155   3B61 70                  LD	    (HL),B          ; Store it to PBUFF
4156   3B62 23                  INC	    HL              ; Next location
4157   3B63 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4158   3B64 23                  INC     HL              ; Next location
4159   3B65 7B          HEX2:   LD	    A,E             ; Get lower byte
4160   3B66 CD 82 3B            CALL    BYT2ASC         ; Convert E to ASCII
4161   3B69 7A          		LD      A,D
4162   3B6A FE 00               CP      $0
4163   3B6C 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4164   3B6E 78          		LD      A,B
4165   3B6F FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4166   3B71 28 02       		JR      Z,HEX4
4167   3B73 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4168   3B74 23                  INC     HL              ; Next location
4169   3B75 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4170   3B76 23                  INC     HL              ; PBUFF+4 to zero
4171   3B77 AF                  XOR     A               ; Terminating character
4172   3B78 77                  LD      (HL),A          ; Store zero to terminate
4173   3B79 23                  INC     HL              ; Make sure PBUFF is terminated
4174   3B7A 77                  LD      (HL),A          ; Store the double zero there
4175   3B7B C1                  POP     BC              ; Get BC back
4176   3B7C 21 79 41            LD      HL,PBUFF        ; Reset to start of PBUFF
4177   3B7F C3 DB 30            JP      STR1            ; Convert the PBUFF to a string and return it
4178   3B82             
4179   3B82 47          BYT2ASC	LD      B,A             ; Save original value
4180   3B83 E6 0F               AND     $0F             ; Strip off upper nybble
4181   3B85 FE 0A               CP      $0A             ; 0-9?
4182   3B87 38 02               JR      C,ADD30         ; If A-F, add 7 more
4183   3B89 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4184   3B8B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4185   3B8D 4F                  LD      C,A             ; Save converted char to C
4186   3B8E 78                  LD      A,B             ; Retrieve original value
4187   3B8F 0F                  RRCA                    ; and Rotate it right
4188   3B90 0F                  RRCA
4189   3B91 0F                  RRCA
4190   3B92 0F                  RRCA
4191   3B93 E6 0F               AND     $0F             ; Mask off upper nybble
4192   3B95 FE 0A               CP      $0A             ; 0-9? < A hex?
4193   3B97 38 02               JR      C,ADD301        ; Skip Add 7
4194   3B99 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4195   3B9B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4196   3B9D 47                  LD      B,A             ; Store high order byte
4197   3B9E C9                  RET	
4198   3B9F             
4199   3B9F             ; Convert "&Hnnnn" to FPREG
4200   3B9F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4201   3B9F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4202   3B9F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4203   3BA0 21 00 00            LD      HL,$0000        ; Zero out the value
4204   3BA3 CD B8 3B            CALL    GETHEX          ; Check the number for valid hex
4205   3BA6 DA D8 3B            JP      C,HXERR         ; First value wasn't hex, HX error
4206   3BA9 18 05               JR      HEXLP1          ; Convert first character
4207   3BAB CD B8 3B    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4208   3BAE 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4209   3BB0 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4210   3BB1 29                  ADD     HL,HL
4211   3BB2 29                  ADD     HL,HL
4212   3BB3 29                  ADD     HL,HL
4213   3BB4 B5                  OR      L               ; Add in D0-D3 into L
4214   3BB5 6F                  LD      L,A             ; Save new value
4215   3BB6 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4216   3BB8             
4217   3BB8 13          GETHEX  INC     DE              ; Next location
4218   3BB9 1A                  LD      A,(DE)          ; Load character at pointer
4219   3BBA FE 20               CP      ' '
4220   3BBC CA B8 3B            JP      Z,GETHEX        ; Skip spaces
4221   3BBF D6 30               SUB     $30             ; Get absolute value
4222   3BC1 D8                  RET     C               ; < "0", error
4223   3BC2 FE 0A               CP      $0A
4224   3BC4 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4225   3BC6 D6 07               SUB     $07             ; Reduce to A-F
4226   3BC8 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4227   3BCA D8                  RET     C               ; CY set if was :            ; < = > ? @
4228   3BCB FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4229   3BCD 3F                  CCF
4230   3BCE C9                  RET                     ; CY set if it wasn't valid hex
4231   3BCF                 
4232   3BCF EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4233   3BD0 7A                  LD      A,D             ; Load DE into AC
4234   3BD1 4B                  LD      C,E             ; For prep to 
4235   3BD2 E5                  PUSH    HL
4236   3BD3 CD 2C 30            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4237   3BD6 E1                  POP     HL
4238   3BD7 C9                  RET
4239   3BD8             
4240   3BD8 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4241   3BDA C3 C1 23            JP      ERROR
4242   3BDD             
4243   3BDD             ; BIN$(NN) Convert integer to a 1-16 char binary string
4244   3BDD CD 75 2C    BIN:    CALL    TSTNUM          ; Verify it's a number
4245   3BE0 CD B7 28            CALL    DEINT           ; Get integer -32768 to 32767
4246   3BE3 C5          BIN2:   PUSH    BC              ; Save contents of BC
4247   3BE4 21 79 41            LD      HL,PBUFF
4248   3BE7 06 11               LD      B,17            ; One higher than max char count
4249   3BE9             ZEROSUP:                        ; Suppress leading zeros
4250   3BE9 05                  DEC     B               ; Max 16 chars
4251   3BEA 78                  LD      A,B
4252   3BEB FE 01               CP      $01
4253   3BED 28 08               JR      Z,BITOUT        ; Always output at least one character
4254   3BEF CB 13               RL      E
4255   3BF1 CB 12               RL      D
4256   3BF3 30 F4               JR      NC,ZEROSUP
4257   3BF5 18 04               JR      BITOUT2
4258   3BF7             BITOUT:      
4259   3BF7 CB 13               RL      E
4260   3BF9 CB 12               RL      D               ; Top bit now in carry
4261   3BFB             BITOUT2:
4262   3BFB 3E 30               LD      A,'0'           ; Char for '0'
4263   3BFD CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4264   3BFF 77                  LD      (HL),A
4265   3C00 23                  INC     HL
4266   3C01 05                  DEC     B
4267   3C02 20 F3               JR      NZ,BITOUT
4268   3C04 AF                  XOR     A               ; Terminating character
4269   3C05 77                  LD      (HL),A          ; Store zero to terminate
4270   3C06 23                  INC     HL              ; Make sure PBUFF is terminated
4271   3C07 77                  LD      (HL),A          ; Store the double zero there
4272   3C08 C1                  POP     BC
4273   3C09 21 79 41            LD      HL,PBUFF
4274   3C0C C3 DB 30            JP      STR1
4275   3C0F             
4276   3C0F             ; Convert "&Bnnnn" to FPREG
4277   3C0F             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4278   3C0F EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4279   3C10 21 00 00            LD      HL,$0000        ; Zero out the value
4280   3C13 CD 2C 3C            CALL    CHKBIN          ; Check the number for valid bin
4281   3C16 DA 3A 3C            JP      C,BINERR        ; First value wasn't bin, HX error
4282   3C19 D6 30       BINIT:  SUB     '0'
4283   3C1B 29                  ADD     HL,HL           ; Rotate HL left
4284   3C1C B5                  OR      L
4285   3C1D 6F                  LD      L,A
4286   3C1E CD 2C 3C            CALL    CHKBIN          ; Get second and addtional characters
4287   3C21 30 F6               JR      NC,BINIT        ; Process if a bin character
4288   3C23 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4289   3C24 7A                  LD      A,D             ; Load DE into AC
4290   3C25 4B                  LD      C,E             ; For prep to 
4291   3C26 E5                  PUSH    HL
4292   3C27 CD 2C 30            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4293   3C2A E1                  POP     HL
4294   3C2B C9                  RET
4295   3C2C             
4296   3C2C             ; Char is in A, NC if char is 0 or 1
4297   3C2C 13          CHKBIN: INC     DE
4298   3C2D 1A                  LD      A,(DE)
4299   3C2E FE 20               CP      ' '
4300   3C30 CA 2C 3C            JP      Z,CHKBIN        ; Skip spaces
4301   3C33 FE 30               CP      '0'             ; Set C if < '0'
4302   3C35 D8                  RET     C
4303   3C36 FE 32               CP      '2'
4304   3C38 3F                  CCF                     ; Set C if > '1'
4305   3C39 C9                  RET
4306   3C3A             
4307   3C3A 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4308   3C3C C3 C1 23            JP      ERROR
4309   3C3F             
4310   3C3F             
4311   3C3F             JJUMP1: 
4312   3C3F DD 21 FF FF         LD      IX,-1           ; Flag cold start
4313   3C43 C3 11 20            JP      CSTART          ; Go and initialise
4314   3C46             
4315   3C46             MONOUT: 
4316   3C46 C3 08 00            JP      $0008           ; output a char
4317   3C49             
4318   3C49             
4319   3C49             MONITR: 
4320   3C49 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4321   3C4C             
4322   3C4C             
4323   3C4C 3E 00       INITST: LD      A,0             ; Clear break flag
4324   3C4E 32 DD 40            LD      (BRKFLG),A
4325   3C51 C3 18 20            JP      INIT
4326   3C54             
4327   3C54 ED 45       ARETN:  RETN                    ; Return from NMI
4328   3C56             
4329   3C56             
4330   3C56 F5          TSTBIT: PUSH    AF              ; Save bit mask
4331   3C57 A0                  AND     B               ; Get common bits
4332   3C58 C1                  POP     BC              ; Restore bit mask
4333   3C59 B8                  CP      B               ; Same bit set?
4334   3C5A 3E 00               LD      A,0             ; Return 0 in A
4335   3C5C C9                  RET
4336   3C5D             
4337   3C5D CD 86 26    OUTNCR: CALL    OUTC            ; Output character in A
4338   3C60 C3 AD 2A            JP      PRNTCRLF        ; Output CRLF
4339   3C63             
4340   3C63             .end
4341   3C63             
tasm: Number of errors = 0
